/* tslint:disable */
/* eslint-disable */
/**
 * Automated Monitoring of Insects ML Platform API
 * Documentation of API endpoints of Automated Monitoring of Insects ML Platform
 *
 * The version of the OpenAPI document: 1.0.0 (api)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Activation
 */
export interface Activation {
    /**
     * 
     * @type {string}
     * @memberof Activation
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof Activation
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Algorithm
 */
export interface Algorithm {
    /**
     * 
     * @type {number}
     * @memberof Algorithm
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Algorithm
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'version_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Algorithm
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface CaptureDetections
 */
export interface CaptureDetections {
    /**
     * 
     * @type {number}
     * @memberof CaptureDetections
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CaptureDetections
     */
    'url': string | null;
    /**
     * 
     * @type {number}
     * @memberof CaptureDetections
     */
    'width': number | null;
    /**
     * 
     * @type {number}
     * @memberof CaptureDetections
     */
    'height': number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CaptureDetections
     */
    'bbox'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {CaptureOccurrence}
     * @memberof CaptureDetections
     */
    'occurrence': CaptureOccurrence;
    /**
     * 
     * @type {string}
     * @memberof CaptureDetections
     */
    'classifications': string;
}
/**
 * 
 * @export
 * @interface CaptureOccurrence
 */
export interface CaptureOccurrence {
    /**
     * 
     * @type {number}
     * @memberof CaptureOccurrence
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CaptureOccurrence
     */
    'details': string;
    /**
     * 
     * @type {TaxonNoParentNested}
     * @memberof CaptureOccurrence
     */
    'determination': TaxonNoParentNested;
    /**
     * 
     * @type {number}
     * @memberof CaptureOccurrence
     */
    'determination_score'?: number | null;
    /**
     * 
     * @type {Algorithm}
     * @memberof CaptureOccurrence
     */
    'determination_algorithm': Algorithm;
}
/**
 * 
 * @export
 * @interface CaptureTaxon
 */
export interface CaptureTaxon {
    /**
     * 
     * @type {number}
     * @memberof CaptureTaxon
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CaptureTaxon
     */
    'name': string;
    /**
     * 
     * @type {TaxonParentNested}
     * @memberof CaptureTaxon
     */
    'parent': TaxonParentNested;
    /**
     * 
     * @type {RankEnum}
     * @memberof CaptureTaxon
     */
    'rank'?: RankEnum;
    /**
     * 
     * @type {string}
     * @memberof CaptureTaxon
     */
    'details': string;
}


/**
 * 
 * @export
 * @interface Classification
 */
export interface Classification {
    /**
     * 
     * @type {number}
     * @memberof Classification
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Classification
     */
    'details': string;
    /**
     * 
     * @type {TaxonNested}
     * @memberof Classification
     */
    'taxon': TaxonNested;
    /**
     * 
     * @type {number}
     * @memberof Classification
     */
    'score'?: number | null;
    /**
     * 
     * @type {Algorithm}
     * @memberof Classification
     */
    'algorithm': Algorithm;
    /**
     * 
     * @type {string}
     * @memberof Classification
     */
    'created_at': string;
}
/**
 * Make additional private fields available for the current user.  This is used for the `/users/me/` endpoint. `email` is read-only because it needs be changed via the `/users/set_email/` endpoint. `password` must be changed via the `/users/reset_password/` endpoint.
 * @export
 * @interface CurrentUser
 */
export interface CurrentUser {
    /**
     * 
     * @type {number}
     * @memberof CurrentUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'identifications': string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUser
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface Deployment
 */
export interface Deployment {
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'image'?: string | null;
    /**
     * 
     * @type {Array<DeploymentEventNested>}
     * @memberof Deployment
     */
    'events': Array<DeploymentEventNested>;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'occurrences': string;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'events_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'captures_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'occurrences_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'taxa_count'?: number | null;
    /**
     * 
     * @type {ProjectNested}
     * @memberof Deployment
     */
    'project': ProjectNested;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'first_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'last_date': string | null;
    /**
     * 
     * @type {DeviceNested}
     * @memberof Deployment
     */
    'device': DeviceNested;
    /**
     * 
     * @type {SiteNested}
     * @memberof Deployment
     */
    'research_site': SiteNested;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'project_id': number;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'device_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'research_site_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'data_source': string;
    /**
     * 
     * @type {number}
     * @memberof Deployment
     */
    'data_source_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Deployment
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DeploymentCaptureNested>}
     * @memberof Deployment
     */
    'example_captures': Array<DeploymentCaptureNested>;
}
/**
 * 
 * @export
 * @interface DeploymentCaptureNested
 */
export interface DeploymentCaptureNested {
    /**
     * 
     * @type {number}
     * @memberof DeploymentCaptureNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentCaptureNested
     */
    'details': string;
    /**
     * Return the public URL for this image.  The base URL is determined by the deployment\'s data source and is cached on the source image. If the deployment\'s data source changes, the URLs for all source images will be updated.  @TODO use signed URLs if necessary. @TODO add support for thumbnail URLs here? @TODO consider if we ever need to access the original image directly!
     * @type {string}
     * @memberof DeploymentCaptureNested
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentCaptureNested
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentCaptureNested
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentCaptureNested
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {EventNested}
     * @memberof DeploymentCaptureNested
     */
    'event': EventNested;
}
/**
 * 
 * @export
 * @interface DeploymentEventNested
 */
export interface DeploymentEventNested {
    /**
     * 
     * @type {number}
     * @memberof DeploymentEventNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentEventNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentEventNested
     */
    'details': string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentEventNested
     */
    'occurrences_count': number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentEventNested
     */
    'taxa_count': number;
}
/**
 * 
 * @export
 * @interface DeploymentList
 */
export interface DeploymentList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'events': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'occurrences': string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentList
     */
    'events_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentList
     */
    'captures_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentList
     */
    'occurrences_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentList
     */
    'taxa_count'?: number | null;
    /**
     * 
     * @type {ProjectNested}
     * @memberof DeploymentList
     */
    'project': ProjectNested;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentList
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentList
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'first_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentList
     */
    'last_date': string | null;
    /**
     * 
     * @type {DeviceNested}
     * @memberof DeploymentList
     */
    'device': DeviceNested;
    /**
     * 
     * @type {SiteNested}
     * @memberof DeploymentList
     */
    'research_site': SiteNested;
}
/**
 * 
 * @export
 * @interface DeploymentNested
 */
export interface DeploymentNested {
    /**
     * 
     * @type {number}
     * @memberof DeploymentNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentNested
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface DeploymentNestedSerializerWithLocationAndCounts
 */
export interface DeploymentNestedSerializerWithLocationAndCounts {
    /**
     * 
     * @type {number}
     * @memberof DeploymentNestedSerializerWithLocationAndCounts
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentNestedSerializerWithLocationAndCounts
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentNestedSerializerWithLocationAndCounts
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentNestedSerializerWithLocationAndCounts
     */
    'details': string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentNestedSerializerWithLocationAndCounts
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentNestedSerializerWithLocationAndCounts
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeploymentNestedSerializerWithLocationAndCounts
     */
    'events_count'?: number | null;
}
/**
 * 
 * @export
 * @interface Detection
 */
export interface Detection {
    /**
     * 
     * @type {number}
     * @memberof Detection
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Detection
     */
    'details': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Detection
     */
    'bbox'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof Detection
     */
    'width': number | null;
    /**
     * 
     * @type {number}
     * @memberof Detection
     */
    'height': number | null;
    /**
     * 
     * @type {string}
     * @memberof Detection
     */
    'occurrence'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Detection
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Detection
     */
    'source_image': string;
    /**
     * 
     * @type {Algorithm}
     * @memberof Detection
     */
    'detection_algorithm': Algorithm;
    /**
     * 
     * @type {string}
     * @memberof Detection
     */
    'url': string | null;
    /**
     * 
     * @type {number}
     * @memberof Detection
     */
    'detection_algorithm_id': number;
}
/**
 * 
 * @export
 * @interface DetectionCaptureNested
 */
export interface DetectionCaptureNested {
    /**
     * 
     * @type {number}
     * @memberof DetectionCaptureNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DetectionCaptureNested
     */
    'details': string;
    /**
     * Return the public URL for this image.  The base URL is determined by the deployment\'s data source and is cached on the source image. If the deployment\'s data source changes, the URLs for all source images will be updated.  @TODO use signed URLs if necessary. @TODO add support for thumbnail URLs here? @TODO consider if we ever need to access the original image directly!
     * @type {string}
     * @memberof DetectionCaptureNested
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof DetectionCaptureNested
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DetectionCaptureNested
     */
    'height'?: number | null;
}
/**
 * 
 * @export
 * @interface DetectionList
 */
export interface DetectionList {
    /**
     * 
     * @type {number}
     * @memberof DetectionList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DetectionList
     */
    'details': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DetectionList
     */
    'bbox'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof DetectionList
     */
    'width': number | null;
    /**
     * 
     * @type {number}
     * @memberof DetectionList
     */
    'height': number | null;
    /**
     * 
     * @type {string}
     * @memberof DetectionList
     */
    'occurrence'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetectionList
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetectionList
     */
    'source_image': string;
    /**
     * 
     * @type {string}
     * @memberof DetectionList
     */
    'detection_algorithm'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetectionList
     */
    'url': string | null;
}
/**
 * 
 * @export
 * @interface DetectionNested
 */
export interface DetectionNested {
    /**
     * 
     * @type {number}
     * @memberof DetectionNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DetectionNested
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetectionNested
     */
    'url': string | null;
    /**
     * 
     * @type {DetectionCaptureNested}
     * @memberof DetectionNested
     */
    'capture': DetectionCaptureNested;
    /**
     * 
     * @type {number}
     * @memberof DetectionNested
     */
    'width': number | null;
    /**
     * 
     * @type {number}
     * @memberof DetectionNested
     */
    'height': number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DetectionNested
     */
    'bbox'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof DetectionNested
     */
    'occurrence'?: string | null;
    /**
     * 
     * @type {Array<Classification>}
     * @memberof DetectionNested
     */
    'classifications': Array<Classification>;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'project': number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DeviceNested
 */
export interface DeviceNested {
    /**
     * 
     * @type {number}
     * @memberof DeviceNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DeviceNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceNested
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'details': string;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof Event
     */
    'deployment': DeploymentNested;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'deployment_id': number;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'end': string;
    /**
     * Consider the start of the event to be the day it occurred on.  Most overnight monitoring sessions will start in the evening and end the next morning.
     * @type {string}
     * @memberof Event
     */
    'day': string;
    /**
     * Format the date range for display.  If the start and end dates are different, display them as: Jan 1-5, 2021
     * @type {string}
     * @memberof Event
     */
    'date_label': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'duration': string;
    /**
     * Format the duration for display.  If duration was populated by a query annotation, use that otherwise call the duration() method to calculate it.
     * @type {string}
     * @memberof Event
     */
    'duration_label': string;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'captures_count': number | null;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'detections_count': number | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'occurrences_count': string;
    /**
     * 
     * @type {{ [key: string]: number | null; }}
     * @memberof Event
     */
    'stats': { [key: string]: number | null; };
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'taxa_count': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'captures': string;
    /**
     * 
     * @type {EventCaptureNested}
     * @memberof Event
     */
    'first_capture': EventCaptureNested;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'summary_data': string;
    /**
     * Look up the source image (capture) that contains a specific detection or occurrence.  Return the page offset for the capture to be used when requesting the capture list endpoint.
     * @type {number}
     * @memberof Event
     */
    'capture_page_offset': number | null;
}
/**
 * Load the first capture for an event. Or @TODO a single capture from the URL params.
 * @export
 * @interface EventCaptureNested
 */
export interface EventCaptureNested {
    /**
     * 
     * @type {number}
     * @memberof EventCaptureNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EventCaptureNested
     */
    'details': string;
    /**
     * Return the public URL for this image.  The base URL is determined by the deployment\'s data source and is cached on the source image. If the deployment\'s data source changes, the URLs for all source images will be updated.  @TODO use signed URLs if necessary. @TODO add support for thumbnail URLs here? @TODO consider if we ever need to access the original image directly!
     * @type {string}
     * @memberof EventCaptureNested
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof EventCaptureNested
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EventCaptureNested
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EventCaptureNested
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EventCaptureNested
     */
    'detections_count'?: number | null;
    /**
     * 
     * @type {Array<CaptureDetections>}
     * @memberof EventCaptureNested
     */
    'detections': Array<CaptureDetections>;
}
/**
 * 
 * @export
 * @interface EventList
 */
export interface EventList {
    /**
     * 
     * @type {number}
     * @memberof EventList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EventList
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventList
     */
    'details': string;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof EventList
     */
    'deployment': DeploymentNested;
    /**
     * The timestamp of the first image in the event.
     * @type {string}
     * @memberof EventList
     */
    'start': string;
    /**
     * The timestamp of the last image in the event.
     * @type {string}
     * @memberof EventList
     */
    'end'?: string | null;
    /**
     * Consider the start of the event to be the day it occurred on.  Most overnight monitoring sessions will start in the evening and end the next morning.
     * @type {string}
     * @memberof EventList
     */
    'day': string;
    /**
     * Format the date range for display.  If the start and end dates are different, display them as: Jan 1-5, 2021
     * @type {string}
     * @memberof EventList
     */
    'date_label': string;
    /**
     * 
     * @type {string}
     * @memberof EventList
     */
    'duration': string;
    /**
     * Format the duration for display.  If duration was populated by a query annotation, use that otherwise call the duration() method to calculate it.
     * @type {string}
     * @memberof EventList
     */
    'duration_label': string;
    /**
     * 
     * @type {number}
     * @memberof EventList
     */
    'captures_count': number | null;
    /**
     * 
     * @type {number}
     * @memberof EventList
     */
    'detections_count': number | null;
    /**
     * 
     * @type {number}
     * @memberof EventList
     */
    'occurrences_count': number | null;
    /**
     * 
     * @type {number}
     * @memberof EventList
     */
    'taxa_count': number;
    /**
     * 
     * @type {string}
     * @memberof EventList
     */
    'captures': string;
    /**
     * 
     * @type {Array<SourceImageNested>}
     * @memberof EventList
     */
    'example_captures': Array<SourceImageNested>;
}
/**
 * 
 * @export
 * @interface EventNested
 */
export interface EventNested {
    /**
     * 
     * @type {number}
     * @memberof EventNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EventNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventNested
     */
    'details': string;
    /**
     * Format the date range for display.  If the start and end dates are different, display them as: Jan 1-5, 2021
     * @type {string}
     * @memberof EventNested
     */
    'date_label': string;
}
/**
 * 
 * @export
 * @interface Identification
 */
export interface Identification {
    /**
     * 
     * @type {number}
     * @memberof Identification
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Identification
     */
    'details': string;
    /**
     * 
     * @type {UserNested}
     * @memberof Identification
     */
    'user': UserNested;
    /**
     * 
     * @type {OccurrenceNested}
     * @memberof Identification
     */
    'occurrence': OccurrenceNested;
    /**
     * 
     * @type {number}
     * @memberof Identification
     */
    'occurrence_id': number;
    /**
     * 
     * @type {TaxonNested}
     * @memberof Identification
     */
    'taxon': TaxonNested;
    /**
     * 
     * @type {number}
     * @memberof Identification
     */
    'taxon_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof Identification
     */
    'withdrawn'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Identification
     */
    'agreed_with_identification_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Identification
     */
    'agreed_with_prediction_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Identification
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Identification
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'delay': number;
    /**
     * Limit the number of images to process
     * @type {number}
     * @memberof Job
     */
    'limit'?: number | null;
    /**
     * Process images in a random order
     * @type {boolean}
     * @memberof Job
     */
    'shuffle'?: boolean;
    /**
     * 
     * @type {JobProjectNested}
     * @memberof Job
     */
    'project': JobProjectNested;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'project_id': number;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof Job
     */
    'deployment': DeploymentNested;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'deployment_id'?: number | null;
    /**
     * 
     * @type {SourceImageCollectionNested}
     * @memberof Job
     */
    'source_image_collection': SourceImageCollectionNested;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'source_image_collection_id'?: number | null;
    /**
     * 
     * @type {SourceImageNested}
     * @memberof Job
     */
    'source_image_single': SourceImageNested;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'source_image_single_id'?: number | null;
    /**
     * 
     * @type {PipelineNested}
     * @memberof Job
     */
    'pipeline': PipelineNested;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'pipeline_id'?: number | null;
    /**
     * 
     * @type {StatusEnum}
     * @memberof Job
     */
    'status': StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'started_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'finished_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'duration': string | null;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'progress': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Job
     */
    'result': { [key: string]: any; } | null;
}


/**
 * 
 * @export
 * @interface JobList
 */
export interface JobList {
    /**
     * 
     * @type {number}
     * @memberof JobList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof JobList
     */
    'delay': number;
    /**
     * Limit the number of images to process
     * @type {number}
     * @memberof JobList
     */
    'limit'?: number | null;
    /**
     * Process images in a random order
     * @type {boolean}
     * @memberof JobList
     */
    'shuffle'?: boolean;
    /**
     * 
     * @type {JobProjectNested}
     * @memberof JobList
     */
    'project': JobProjectNested;
    /**
     * 
     * @type {number}
     * @memberof JobList
     */
    'project_id': number;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof JobList
     */
    'deployment': DeploymentNested;
    /**
     * 
     * @type {number}
     * @memberof JobList
     */
    'deployment_id'?: number | null;
    /**
     * 
     * @type {SourceImageCollectionNested}
     * @memberof JobList
     */
    'source_image_collection': SourceImageCollectionNested;
    /**
     * 
     * @type {number}
     * @memberof JobList
     */
    'source_image_collection_id'?: number | null;
    /**
     * 
     * @type {SourceImageNested}
     * @memberof JobList
     */
    'source_image_single': SourceImageNested;
    /**
     * 
     * @type {number}
     * @memberof JobList
     */
    'source_image_single_id'?: number | null;
    /**
     * 
     * @type {PipelineNested}
     * @memberof JobList
     */
    'pipeline': PipelineNested;
    /**
     * 
     * @type {number}
     * @memberof JobList
     */
    'pipeline_id'?: number | null;
    /**
     * 
     * @type {StatusEnum}
     * @memberof JobList
     */
    'status': StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'started_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'finished_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'duration': string | null;
    /**
     * 
     * @type {string}
     * @memberof JobList
     */
    'progress': string;
}


/**
 * 
 * @export
 * @interface JobProjectNested
 */
export interface JobProjectNested {
    /**
     * 
     * @type {number}
     * @memberof JobProjectNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof JobProjectNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobProjectNested
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface JobStatus
 */
export interface JobStatus {
    /**
     * 
     * @type {number}
     * @memberof JobStatus
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'details': string;
    /**
     * 
     * @type {StatusEnum}
     * @memberof JobStatus
     */
    'status'?: StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'updated_at': string;
}


/**
 * Serialize detections for manual annotation of objects of interest in Label Studio.  Manually specifies the json output to match the Label Studio task format. https://labelstud.io/guide/tasks.html
 * @export
 * @interface LabelStudioDetection
 */
export interface LabelStudioDetection {
    /**
     * 
     * @type {string}
     * @memberof LabelStudioDetection
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof LabelStudioDetection
     */
    'annotations': string;
    /**
     * 
     * @type {string}
     * @memberof LabelStudioDetection
     */
    'predictions': string;
}
/**
 * Serialize occurrences for manual annotation of objects of interest in Label Studio.  Manually specifies the json output to match the Label Studio task format. https://labelstud.io/guide/tasks.html
 * @export
 * @interface LabelStudioOccurrence
 */
export interface LabelStudioOccurrence {
    /**
     * 
     * @type {string}
     * @memberof LabelStudioOccurrence
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof LabelStudioOccurrence
     */
    'annotations': string;
    /**
     * 
     * @type {string}
     * @memberof LabelStudioOccurrence
     */
    'predictions': string;
}
/**
 * Serialize source images for manual annotation of detected objects in Label Studio.  Manually specifies the json output to match the Label Studio task format. https://labelstud.io/guide/tasks.html#Example-JSON-format
 * @export
 * @interface LabelStudioSourceImage
 */
export interface LabelStudioSourceImage {
    /**
     * 
     * @type {string}
     * @memberof LabelStudioSourceImage
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof LabelStudioSourceImage
     */
    'annotations': string;
    /**
     * 
     * @type {string}
     * @memberof LabelStudioSourceImage
     */
    'predictions': string;
}
/**
 * * `random` - random * `stratified_random` - stratified_random * `interval` - interval * `manual` - manual * `starred` - starred * `random_from_each_event` - random_from_each_event * `last_and_random_from_each_event` - last_and_random_from_each_event * `greatest_file_size_from_each_event` - greatest_file_size_from_each_event * `detections_only` - detections_only
 * @export
 * @enum {string}
 */

export const MethodEnum = {
    Random: 'random',
    StratifiedRandom: 'stratified_random',
    Interval: 'interval',
    Manual: 'manual',
    Starred: 'starred',
    RandomFromEachEvent: 'random_from_each_event',
    LastAndRandomFromEachEvent: 'last_and_random_from_each_event',
    GreatestFileSizeFromEachEvent: 'greatest_file_size_from_each_event',
    DetectionsOnly: 'detections_only'
} as const;

export type MethodEnum = typeof MethodEnum[keyof typeof MethodEnum];


/**
 * 
 * @export
 * @interface Occurrence
 */
export interface Occurrence {
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'details': string;
    /**
     * 
     * @type {EventNested}
     * @memberof Occurrence
     */
    'event': EventNested;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof Occurrence
     */
    'deployment': DeploymentNested;
    /**
     * Return the timestamp of the first appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof Occurrence
     */
    'first_appearance_timestamp': string | null;
    /**
     * Return the time part only of the first appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof Occurrence
     */
    'first_appearance_time': string | null;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'duration': string | null;
    /**
     * If duration has been calculated by a query annotation, use that value otherwise call the duration() method to calculate it.
     * @type {string}
     * @memberof Occurrence
     */
    'duration_label': string | null;
    /**
     * 
     * @type {CaptureTaxon}
     * @memberof Occurrence
     */
    'determination': CaptureTaxon;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'detections_count': number | null;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'detection_images': string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'determination_score': number | null;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'determination_details': string;
    /**
     * 
     * @type {string}
     * @memberof Occurrence
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Occurrence
     */
    'determination_id': number | null;
    /**
     * 
     * @type {Array<DetectionNested>}
     * @memberof Occurrence
     */
    'detections': Array<DetectionNested>;
    /**
     * 
     * @type {Array<OccurrenceIdentification>}
     * @memberof Occurrence
     */
    'identifications': Array<OccurrenceIdentification>;
    /**
     * 
     * @type {Array<OccurrenceClassification>}
     * @memberof Occurrence
     */
    'predictions': Array<OccurrenceClassification>;
}
/**
 * 
 * @export
 * @interface OccurrenceClassification
 */
export interface OccurrenceClassification {
    /**
     * 
     * @type {number}
     * @memberof OccurrenceClassification
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceClassification
     */
    'details': string;
    /**
     * 
     * @type {TaxonNested}
     * @memberof OccurrenceClassification
     */
    'taxon': TaxonNested;
    /**
     * 
     * @type {number}
     * @memberof OccurrenceClassification
     */
    'score'?: number | null;
    /**
     * 
     * @type {Algorithm}
     * @memberof OccurrenceClassification
     */
    'algorithm': Algorithm;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceClassification
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface OccurrenceIdentification
 */
export interface OccurrenceIdentification {
    /**
     * 
     * @type {number}
     * @memberof OccurrenceIdentification
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceIdentification
     */
    'details': string;
    /**
     * 
     * @type {TaxonNested}
     * @memberof OccurrenceIdentification
     */
    'taxon': TaxonNested;
    /**
     * 
     * @type {UserNested}
     * @memberof OccurrenceIdentification
     */
    'user': UserNested;
    /**
     * 
     * @type {boolean}
     * @memberof OccurrenceIdentification
     */
    'withdrawn'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceIdentification
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface OccurrenceList
 */
export interface OccurrenceList {
    /**
     * 
     * @type {number}
     * @memberof OccurrenceList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceList
     */
    'details': string;
    /**
     * 
     * @type {EventNested}
     * @memberof OccurrenceList
     */
    'event': EventNested;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof OccurrenceList
     */
    'deployment': DeploymentNested;
    /**
     * Return the timestamp of the first appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof OccurrenceList
     */
    'first_appearance_timestamp': string | null;
    /**
     * Return the time part only of the first appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof OccurrenceList
     */
    'first_appearance_time': string | null;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceList
     */
    'duration': string | null;
    /**
     * If duration has been calculated by a query annotation, use that value otherwise call the duration() method to calculate it.
     * @type {string}
     * @memberof OccurrenceList
     */
    'duration_label': string | null;
    /**
     * 
     * @type {CaptureTaxon}
     * @memberof OccurrenceList
     */
    'determination': CaptureTaxon;
    /**
     * 
     * @type {number}
     * @memberof OccurrenceList
     */
    'detections_count': number | null;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceList
     */
    'detection_images': string;
    /**
     * 
     * @type {number}
     * @memberof OccurrenceList
     */
    'determination_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceList
     */
    'determination_details': string;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceList
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface OccurrenceNested
 */
export interface OccurrenceNested {
    /**
     * 
     * @type {number}
     * @memberof OccurrenceNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OccurrenceNested
     */
    'details': string;
    /**
     * 
     * @type {CaptureTaxon}
     * @memberof OccurrenceNested
     */
    'determination': CaptureTaxon;
}
/**
 * 
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'name': string;
    /**
     * Unique, URL safe name e.g. about-us
     * @type {string}
     * @memberof Page
     */
    'slug': string;
    /**
     * Use Markdown syntax
     * @type {string}
     * @memberof Page
     */
    'content'?: string | null;
    /**
     * Convert the content field to HTML
     * @type {string}
     * @memberof Page
     */
    'html': string;
    /**
     * 0 = main nav, 1 = sub nav, etc.
     * @type {number}
     * @memberof Page
     */
    'nav_level'?: number;
    /**
     * Order of nav items within a level
     * @type {number}
     * @memberof Page
     */
    'nav_order'?: number;
    /**
     * CSS class for nav link
     * @type {string}
     * @memberof Page
     */
    'link_class'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Page
     */
    'published'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface PageList
 */
export interface PageList {
    /**
     * 
     * @type {number}
     * @memberof PageList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PageList
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof PageList
     */
    'name': string;
    /**
     * Unique, URL safe name e.g. about-us
     * @type {string}
     * @memberof PageList
     */
    'slug': string;
    /**
     * 0 = main nav, 1 = sub nav, etc.
     * @type {number}
     * @memberof PageList
     */
    'nav_level'?: number;
    /**
     * Order of nav items within a level
     * @type {number}
     * @memberof PageList
     */
    'nav_order'?: number;
    /**
     * CSS class for nav link
     * @type {string}
     * @memberof PageList
     */
    'link_class'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PageList
     */
    'published'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PageList
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface PaginatedAlgorithmList
 */
export interface PaginatedAlgorithmList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAlgorithmList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlgorithmList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlgorithmList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Algorithm>}
     * @memberof PaginatedAlgorithmList
     */
    'results'?: Array<Algorithm>;
}
/**
 * 
 * @export
 * @interface PaginatedClassificationList
 */
export interface PaginatedClassificationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedClassificationList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedClassificationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedClassificationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Classification>}
     * @memberof PaginatedClassificationList
     */
    'results'?: Array<Classification>;
}
/**
 * 
 * @export
 * @interface PaginatedDeploymentListList
 */
export interface PaginatedDeploymentListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDeploymentListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeploymentListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeploymentListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DeploymentList>}
     * @memberof PaginatedDeploymentListList
     */
    'results'?: Array<DeploymentList>;
}
/**
 * 
 * @export
 * @interface PaginatedDetectionListList
 */
export interface PaginatedDetectionListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDetectionListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDetectionListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDetectionListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DetectionList>}
     * @memberof PaginatedDetectionListList
     */
    'results'?: Array<DetectionList>;
}
/**
 * 
 * @export
 * @interface PaginatedDeviceList
 */
export interface PaginatedDeviceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDeviceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Device>}
     * @memberof PaginatedDeviceList
     */
    'results'?: Array<Device>;
}
/**
 * 
 * @export
 * @interface PaginatedEventListList
 */
export interface PaginatedEventListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEventListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEventListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEventListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EventList>}
     * @memberof PaginatedEventListList
     */
    'results'?: Array<EventList>;
}
/**
 * 
 * @export
 * @interface PaginatedIdentificationList
 */
export interface PaginatedIdentificationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedIdentificationList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIdentificationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIdentificationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Identification>}
     * @memberof PaginatedIdentificationList
     */
    'results'?: Array<Identification>;
}
/**
 * 
 * @export
 * @interface PaginatedJobListList
 */
export interface PaginatedJobListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedJobListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJobListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJobListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<JobList>}
     * @memberof PaginatedJobListList
     */
    'results'?: Array<JobList>;
}
/**
 * 
 * @export
 * @interface PaginatedLabelStudioDetectionList
 */
export interface PaginatedLabelStudioDetectionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLabelStudioDetectionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabelStudioDetectionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabelStudioDetectionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LabelStudioDetection>}
     * @memberof PaginatedLabelStudioDetectionList
     */
    'results'?: Array<LabelStudioDetection>;
}
/**
 * 
 * @export
 * @interface PaginatedLabelStudioOccurrenceList
 */
export interface PaginatedLabelStudioOccurrenceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLabelStudioOccurrenceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabelStudioOccurrenceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabelStudioOccurrenceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LabelStudioOccurrence>}
     * @memberof PaginatedLabelStudioOccurrenceList
     */
    'results'?: Array<LabelStudioOccurrence>;
}
/**
 * 
 * @export
 * @interface PaginatedLabelStudioSourceImageList
 */
export interface PaginatedLabelStudioSourceImageList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLabelStudioSourceImageList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabelStudioSourceImageList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabelStudioSourceImageList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LabelStudioSourceImage>}
     * @memberof PaginatedLabelStudioSourceImageList
     */
    'results'?: Array<LabelStudioSourceImage>;
}
/**
 * 
 * @export
 * @interface PaginatedOccurrenceListList
 */
export interface PaginatedOccurrenceListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOccurrenceListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOccurrenceListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOccurrenceListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OccurrenceList>}
     * @memberof PaginatedOccurrenceListList
     */
    'results'?: Array<OccurrenceList>;
}
/**
 * 
 * @export
 * @interface PaginatedPageListList
 */
export interface PaginatedPageListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPageListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPageListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPageListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PageList>}
     * @memberof PaginatedPageListList
     */
    'results'?: Array<PageList>;
}
/**
 * 
 * @export
 * @interface PaginatedPipelineList
 */
export interface PaginatedPipelineList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPipelineList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPipelineList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPipelineList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Pipeline>}
     * @memberof PaginatedPipelineList
     */
    'results'?: Array<Pipeline>;
}
/**
 * 
 * @export
 * @interface PaginatedProjectListList
 */
export interface PaginatedProjectListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedProjectListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProjectListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProjectListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ProjectList>}
     * @memberof PaginatedProjectListList
     */
    'results'?: Array<ProjectList>;
}
/**
 * 
 * @export
 * @interface PaginatedSiteList
 */
export interface PaginatedSiteList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSiteList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSiteList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSiteList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Site>}
     * @memberof PaginatedSiteList
     */
    'results'?: Array<Site>;
}
/**
 * 
 * @export
 * @interface PaginatedSourceImageCollectionList
 */
export interface PaginatedSourceImageCollectionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSourceImageCollectionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSourceImageCollectionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSourceImageCollectionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SourceImageCollection>}
     * @memberof PaginatedSourceImageCollectionList
     */
    'results'?: Array<SourceImageCollection>;
}
/**
 * 
 * @export
 * @interface PaginatedSourceImageListList
 */
export interface PaginatedSourceImageListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSourceImageListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSourceImageListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSourceImageListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SourceImageList>}
     * @memberof PaginatedSourceImageListList
     */
    'results'?: Array<SourceImageList>;
}
/**
 * 
 * @export
 * @interface PaginatedSourceImageUploadList
 */
export interface PaginatedSourceImageUploadList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSourceImageUploadList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSourceImageUploadList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSourceImageUploadList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SourceImageUpload>}
     * @memberof PaginatedSourceImageUploadList
     */
    'results'?: Array<SourceImageUpload>;
}
/**
 * 
 * @export
 * @interface PaginatedStorageSourceList
 */
export interface PaginatedStorageSourceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedStorageSourceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStorageSourceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStorageSourceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<StorageSource>}
     * @memberof PaginatedStorageSourceList
     */
    'results'?: Array<StorageSource>;
}
/**
 * 
 * @export
 * @interface PaginatedTaxonListList
 */
export interface PaginatedTaxonListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTaxonListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaxonListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTaxonListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<TaxonList>}
     * @memberof PaginatedTaxonListList
     */
    'results'?: Array<TaxonList>;
}
/**
 * 
 * @export
 * @interface PaginatedUserList
 */
export interface PaginatedUserList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof PaginatedUserList
     */
    'results'?: Array<User>;
}
/**
 * 
 * @export
 * @interface PasswordResetConfirm
 */
export interface PasswordResetConfirm {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface PatchedAlgorithm
 */
export interface PatchedAlgorithm {
    /**
     * 
     * @type {number}
     * @memberof PatchedAlgorithm
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedAlgorithm
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'version_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAlgorithm
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedClassification
 */
export interface PatchedClassification {
    /**
     * 
     * @type {number}
     * @memberof PatchedClassification
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassification
     */
    'details'?: string;
    /**
     * 
     * @type {TaxonNested}
     * @memberof PatchedClassification
     */
    'taxon'?: TaxonNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedClassification
     */
    'score'?: number | null;
    /**
     * 
     * @type {Algorithm}
     * @memberof PatchedClassification
     */
    'algorithm'?: Algorithm;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassification
     */
    'created_at'?: string;
}
/**
 * Make additional private fields available for the current user.  This is used for the `/users/me/` endpoint. `email` is read-only because it needs be changed via the `/users/set_email/` endpoint. `password` must be changed via the `/users/reset_password/` endpoint.
 * @export
 * @interface PatchedCurrentUser
 */
export interface PatchedCurrentUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedCurrentUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrentUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrentUser
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrentUser
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrentUser
     */
    'identifications'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCurrentUser
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface PatchedDeployment
 */
export interface PatchedDeployment {
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'image'?: string | null;
    /**
     * 
     * @type {Array<DeploymentEventNested>}
     * @memberof PatchedDeployment
     */
    'events'?: Array<DeploymentEventNested>;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'occurrences'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'events_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'captures_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'occurrences_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'taxa_count'?: number | null;
    /**
     * 
     * @type {ProjectNested}
     * @memberof PatchedDeployment
     */
    'project'?: ProjectNested;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'first_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'last_date'?: string | null;
    /**
     * 
     * @type {DeviceNested}
     * @memberof PatchedDeployment
     */
    'device'?: DeviceNested;
    /**
     * 
     * @type {SiteNested}
     * @memberof PatchedDeployment
     */
    'research_site'?: SiteNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'project_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'device_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'research_site_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'data_source'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeployment
     */
    'data_source_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeployment
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DeploymentCaptureNested>}
     * @memberof PatchedDeployment
     */
    'example_captures'?: Array<DeploymentCaptureNested>;
}
/**
 * 
 * @export
 * @interface PatchedDetection
 */
export interface PatchedDetection {
    /**
     * 
     * @type {number}
     * @memberof PatchedDetection
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedDetection
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedDetection
     */
    'bbox'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDetection
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDetection
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDetection
     */
    'occurrence'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDetection
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDetection
     */
    'source_image'?: string;
    /**
     * 
     * @type {Algorithm}
     * @memberof PatchedDetection
     */
    'detection_algorithm'?: Algorithm;
    /**
     * 
     * @type {string}
     * @memberof PatchedDetection
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDetection
     */
    'detection_algorithm_id'?: number;
}
/**
 * 
 * @export
 * @interface PatchedDevice
 */
export interface PatchedDevice {
    /**
     * 
     * @type {number}
     * @memberof PatchedDevice
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedDevice
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDevice
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDevice
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedDevice
     */
    'project'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedDevice
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDevice
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedEvent
 */
export interface PatchedEvent {
    /**
     * 
     * @type {number}
     * @memberof PatchedEvent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'details'?: string;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof PatchedEvent
     */
    'deployment'?: DeploymentNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedEvent
     */
    'deployment_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'end'?: string;
    /**
     * Consider the start of the event to be the day it occurred on.  Most overnight monitoring sessions will start in the evening and end the next morning.
     * @type {string}
     * @memberof PatchedEvent
     */
    'day'?: string;
    /**
     * Format the date range for display.  If the start and end dates are different, display them as: Jan 1-5, 2021
     * @type {string}
     * @memberof PatchedEvent
     */
    'date_label'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'duration'?: string;
    /**
     * Format the duration for display.  If duration was populated by a query annotation, use that otherwise call the duration() method to calculate it.
     * @type {string}
     * @memberof PatchedEvent
     */
    'duration_label'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedEvent
     */
    'captures_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedEvent
     */
    'detections_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'occurrences_count'?: string;
    /**
     * 
     * @type {{ [key: string]: number | null; }}
     * @memberof PatchedEvent
     */
    'stats'?: { [key: string]: number | null; };
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'taxa_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'captures'?: string;
    /**
     * 
     * @type {EventCaptureNested}
     * @memberof PatchedEvent
     */
    'first_capture'?: EventCaptureNested;
    /**
     * 
     * @type {string}
     * @memberof PatchedEvent
     */
    'summary_data'?: string;
    /**
     * Look up the source image (capture) that contains a specific detection or occurrence.  Return the page offset for the capture to be used when requesting the capture list endpoint.
     * @type {number}
     * @memberof PatchedEvent
     */
    'capture_page_offset'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedIdentification
 */
export interface PatchedIdentification {
    /**
     * 
     * @type {number}
     * @memberof PatchedIdentification
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdentification
     */
    'details'?: string;
    /**
     * 
     * @type {UserNested}
     * @memberof PatchedIdentification
     */
    'user'?: UserNested;
    /**
     * 
     * @type {OccurrenceNested}
     * @memberof PatchedIdentification
     */
    'occurrence'?: OccurrenceNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdentification
     */
    'occurrence_id'?: number;
    /**
     * 
     * @type {TaxonNested}
     * @memberof PatchedIdentification
     */
    'taxon'?: TaxonNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdentification
     */
    'taxon_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIdentification
     */
    'withdrawn'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdentification
     */
    'agreed_with_identification_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdentification
     */
    'agreed_with_prediction_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdentification
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdentification
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedJob
 */
export interface PatchedJob {
    /**
     * 
     * @type {number}
     * @memberof PatchedJob
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedJob
     */
    'delay'?: number;
    /**
     * Limit the number of images to process
     * @type {number}
     * @memberof PatchedJob
     */
    'limit'?: number | null;
    /**
     * Process images in a random order
     * @type {boolean}
     * @memberof PatchedJob
     */
    'shuffle'?: boolean;
    /**
     * 
     * @type {JobProjectNested}
     * @memberof PatchedJob
     */
    'project'?: JobProjectNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedJob
     */
    'project_id'?: number;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof PatchedJob
     */
    'deployment'?: DeploymentNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedJob
     */
    'deployment_id'?: number | null;
    /**
     * 
     * @type {SourceImageCollectionNested}
     * @memberof PatchedJob
     */
    'source_image_collection'?: SourceImageCollectionNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedJob
     */
    'source_image_collection_id'?: number | null;
    /**
     * 
     * @type {SourceImageNested}
     * @memberof PatchedJob
     */
    'source_image_single'?: SourceImageNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedJob
     */
    'source_image_single_id'?: number | null;
    /**
     * 
     * @type {PipelineNested}
     * @memberof PatchedJob
     */
    'pipeline'?: PipelineNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedJob
     */
    'pipeline_id'?: number | null;
    /**
     * 
     * @type {StatusEnum}
     * @memberof PatchedJob
     */
    'status'?: StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'finished_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'duration'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedJob
     */
    'progress'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedJob
     */
    'result'?: { [key: string]: any; } | null;
}


/**
 * 
 * @export
 * @interface PatchedOccurrence
 */
export interface PatchedOccurrence {
    /**
     * 
     * @type {number}
     * @memberof PatchedOccurrence
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'details'?: string;
    /**
     * 
     * @type {EventNested}
     * @memberof PatchedOccurrence
     */
    'event'?: EventNested;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof PatchedOccurrence
     */
    'deployment'?: DeploymentNested;
    /**
     * Return the timestamp of the first appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'first_appearance_timestamp'?: string | null;
    /**
     * Return the time part only of the first appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'first_appearance_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'duration'?: string | null;
    /**
     * If duration has been calculated by a query annotation, use that value otherwise call the duration() method to calculate it.
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'duration_label'?: string | null;
    /**
     * 
     * @type {CaptureTaxon}
     * @memberof PatchedOccurrence
     */
    'determination'?: CaptureTaxon;
    /**
     * 
     * @type {number}
     * @memberof PatchedOccurrence
     */
    'detections_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'detection_images'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOccurrence
     */
    'determination_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'determination_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOccurrence
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOccurrence
     */
    'determination_id'?: number | null;
    /**
     * 
     * @type {Array<DetectionNested>}
     * @memberof PatchedOccurrence
     */
    'detections'?: Array<DetectionNested>;
    /**
     * 
     * @type {Array<OccurrenceIdentification>}
     * @memberof PatchedOccurrence
     */
    'identifications'?: Array<OccurrenceIdentification>;
    /**
     * 
     * @type {Array<OccurrenceClassification>}
     * @memberof PatchedOccurrence
     */
    'predictions'?: Array<OccurrenceClassification>;
}
/**
 * 
 * @export
 * @interface PatchedPage
 */
export interface PatchedPage {
    /**
     * 
     * @type {number}
     * @memberof PatchedPage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPage
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPage
     */
    'name'?: string;
    /**
     * Unique, URL safe name e.g. about-us
     * @type {string}
     * @memberof PatchedPage
     */
    'slug'?: string;
    /**
     * Use Markdown syntax
     * @type {string}
     * @memberof PatchedPage
     */
    'content'?: string | null;
    /**
     * Convert the content field to HTML
     * @type {string}
     * @memberof PatchedPage
     */
    'html'?: string;
    /**
     * 0 = main nav, 1 = sub nav, etc.
     * @type {number}
     * @memberof PatchedPage
     */
    'nav_level'?: number;
    /**
     * Order of nav items within a level
     * @type {number}
     * @memberof PatchedPage
     */
    'nav_order'?: number;
    /**
     * CSS class for nav link
     * @type {string}
     * @memberof PatchedPage
     */
    'link_class'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPage
     */
    'published'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedPage
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedPipeline
 */
export interface PatchedPipeline {
    /**
     * 
     * @type {number}
     * @memberof PatchedPipeline
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPipeline
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'version_name'?: string;
    /**
     * 
     * @type {Array<Algorithm>}
     * @memberof PatchedPipeline
     */
    'algorithms'?: Array<Algorithm>;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'stages'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'endpoint_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPipeline
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedProject
 */
export interface PatchedProject {
    /**
     * 
     * @type {number}
     * @memberof PatchedProject
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedProject
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProject
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProject
     */
    'details'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedProject
     */
    'deployments_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedProject
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProject
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProject
     */
    'image'?: string | null;
    /**
     * 
     * @type {Array<DeploymentNestedSerializerWithLocationAndCounts>}
     * @memberof PatchedProject
     */
    'deployments'?: Array<DeploymentNestedSerializerWithLocationAndCounts>;
    /**
     * 
     * @type {string}
     * @memberof PatchedProject
     */
    'summary_data'?: string;
}
/**
 * 
 * @export
 * @interface PatchedSite
 */
export interface PatchedSite {
    /**
     * 
     * @type {number}
     * @memberof PatchedSite
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSite
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSite
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSite
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSite
     */
    'project'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedSite
     */
    'boundary_rect'?: Array<number> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSite
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSite
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedSourceImage
 */
export interface PatchedSourceImage {
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImage
     */
    'details'?: string;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof PatchedSourceImage
     */
    'deployment'?: DeploymentNested;
    /**
     * 
     * @type {EventNested}
     * @memberof PatchedSourceImage
     */
    'event'?: EventNested;
    /**
     * Return the public URL for this image.  The base URL is determined by the deployment\'s data source and is cached on the source image. If the deployment\'s data source changes, the URLs for all source images will be updated.  @TODO use signed URLs if necessary. @TODO add support for thumbnail URLs here? @TODO consider if we ever need to access the original image directly!
     * @type {string}
     * @memberof PatchedSourceImage
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImage
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImage
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImage
     */
    'height'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImage
     */
    'size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImage
     */
    'detections_count'?: number;
    /**
     * 
     * @type {Array<CaptureDetections>}
     * @memberof PatchedSourceImage
     */
    'detections'?: Array<CaptureDetections>;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImage
     */
    'uploaded_by'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSourceImage
     */
    'test_image'?: boolean;
    /**
     * 
     * @type {Array<JobStatus>}
     * @memberof PatchedSourceImage
     */
    'jobs'?: Array<JobStatus>;
    /**
     * 
     * @type {Array<SourceImageCollectionNested>}
     * @memberof PatchedSourceImage
     */
    'collections'?: Array<SourceImageCollectionNested>;
}
/**
 * 
 * @export
 * @interface PatchedSourceImageCollection
 */
export interface PatchedSourceImageCollection {
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImageCollection
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageCollection
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageCollection
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImageCollection
     */
    'project'?: number;
    /**
     * 
     * @type {MethodEnum}
     * @memberof PatchedSourceImageCollection
     */
    'method'?: MethodEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedSourceImageCollection
     */
    'kwargs'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageCollection
     */
    'source_images'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageCollection
     */
    'source_image_count'?: string;
    /**
     * 
     * @type {Array<JobStatus>}
     * @memberof PatchedSourceImageCollection
     */
    'jobs'?: Array<JobStatus>;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageCollection
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageCollection
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @interface PatchedSourceImageUpload
 */
export interface PatchedSourceImageUpload {
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImageUpload
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageUpload
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageUpload
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImageUpload
     */
    'deployment'?: number;
    /**
     * 
     * @type {SourceImageNested}
     * @memberof PatchedSourceImageUpload
     */
    'source_image'?: SourceImageNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedSourceImageUpload
     */
    'user'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSourceImageUpload
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedStorageSource
 */
export interface PatchedStorageSource {
    /**
     * 
     * @type {number}
     * @memberof PatchedStorageSource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'bucket'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'access_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'secret_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'endpoint_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'public_base_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedStorageSource
     */
    'project'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedStorageSource
     */
    'total_files'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStorageSource
     */
    'total_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'last_checked'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageSource
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedTaxon
 */
export interface PatchedTaxon {
    /**
     * 
     * @type {number}
     * @memberof PatchedTaxon
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedTaxon
     */
    'name'?: string;
    /**
     * 
     * @type {RankEnum}
     * @memberof PatchedTaxon
     */
    'rank'?: RankEnum;
    /**
     * 
     * @type {TaxonNested}
     * @memberof PatchedTaxon
     */
    'parent'?: TaxonNested;
    /**
     * 
     * @type {number}
     * @memberof PatchedTaxon
     */
    'parent_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedTaxon
     */
    'details'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedTaxon
     */
    'occurrences_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedTaxon
     */
    'detections_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedTaxon
     */
    'events_count'?: number;
    /**
     * 
     * @type {Array<TaxonOccurrenceNested>}
     * @memberof PatchedTaxon
     */
    'occurrences'?: Array<TaxonOccurrenceNested>;
}


/**
 * 
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'identifications'?: string;
}
/**
 * 
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'version_name'?: string;
    /**
     * 
     * @type {Array<Algorithm>}
     * @memberof Pipeline
     */
    'algorithms': Array<Algorithm>;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'stages': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'endpoint_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface PipelineNested
 */
export interface PipelineNested {
    /**
     * 
     * @type {number}
     * @memberof PipelineNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PipelineNested
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineNested
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineNested
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineNested
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineNested
     */
    'version_name'?: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'details': string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'deployments_count': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'image'?: string | null;
    /**
     * 
     * @type {Array<DeploymentNestedSerializerWithLocationAndCounts>}
     * @memberof Project
     */
    'deployments': Array<DeploymentNestedSerializerWithLocationAndCounts>;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'summary_data': string;
}
/**
 * 
 * @export
 * @interface ProjectList
 */
export interface ProjectList {
    /**
     * 
     * @type {number}
     * @memberof ProjectList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectList
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectList
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectList
     */
    'details': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectList
     */
    'deployments_count': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectList
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectList
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectList
     */
    'image'?: string | null;
}
/**
 * 
 * @export
 * @interface ProjectNested
 */
export interface ProjectNested {
    /**
     * 
     * @type {number}
     * @memberof ProjectNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectNested
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectNested
     */
    'details': string;
}
/**
 * * `ORDER` - Order * `SUPERFAMILY` - Superfamily * `FAMILY` - Family * `SUBFAMILY` - Subfamily * `TRIBE` - Tribe * `SUBTRIBE` - Subtribe * `GENUS` - Genus * `SPECIES` - Species * `UNKNOWN` - Unknown
 * @export
 * @enum {string}
 */

export const RankEnum = {
    Order: 'ORDER',
    Superfamily: 'SUPERFAMILY',
    Family: 'FAMILY',
    Subfamily: 'SUBFAMILY',
    Tribe: 'TRIBE',
    Subtribe: 'SUBTRIBE',
    Genus: 'GENUS',
    Species: 'SPECIES',
    Unknown: 'UNKNOWN'
} as const;

export type RankEnum = typeof RankEnum[keyof typeof RankEnum];


/**
 * 
 * @export
 * @interface SendEmailReset
 */
export interface SendEmailReset {
    /**
     * 
     * @type {string}
     * @memberof SendEmailReset
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SetPassword
 */
export interface SetPassword {
    /**
     * 
     * @type {string}
     * @memberof SetPassword
     */
    'new_password': string;
    /**
     * 
     * @type {string}
     * @memberof SetPassword
     */
    'current_password': string;
}
/**
 * 
 * @export
 * @interface SetUsername
 */
export interface SetUsername {
    /**
     * 
     * @type {string}
     * @memberof SetUsername
     */
    'current_password': string;
    /**
     * 
     * @type {string}
     * @memberof SetUsername
     */
    'new_email': string;
}
/**
 * 
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    'project': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Site
     */
    'boundary_rect': Array<number> | null;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface SiteNested
 */
export interface SiteNested {
    /**
     * 
     * @type {number}
     * @memberof SiteNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SiteNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SiteNested
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface SourceImage
 */
export interface SourceImage {
    /**
     * 
     * @type {number}
     * @memberof SourceImage
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SourceImage
     */
    'details': string;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof SourceImage
     */
    'deployment': DeploymentNested;
    /**
     * 
     * @type {EventNested}
     * @memberof SourceImage
     */
    'event': EventNested;
    /**
     * Return the public URL for this image.  The base URL is determined by the deployment\'s data source and is cached on the source image. If the deployment\'s data source changes, the URLs for all source images will be updated.  @TODO use signed URLs if necessary. @TODO add support for thumbnail URLs here? @TODO consider if we ever need to access the original image directly!
     * @type {string}
     * @memberof SourceImage
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImage
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImage
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImage
     */
    'height'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImage
     */
    'size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImage
     */
    'detections_count': number;
    /**
     * 
     * @type {Array<CaptureDetections>}
     * @memberof SourceImage
     */
    'detections': Array<CaptureDetections>;
    /**
     * 
     * @type {number}
     * @memberof SourceImage
     */
    'uploaded_by': number;
    /**
     * 
     * @type {boolean}
     * @memberof SourceImage
     */
    'test_image'?: boolean;
    /**
     * 
     * @type {Array<JobStatus>}
     * @memberof SourceImage
     */
    'jobs': Array<JobStatus>;
    /**
     * 
     * @type {Array<SourceImageCollectionNested>}
     * @memberof SourceImage
     */
    'collections': Array<SourceImageCollectionNested>;
}
/**
 * 
 * @export
 * @interface SourceImageCollection
 */
export interface SourceImageCollection {
    /**
     * 
     * @type {number}
     * @memberof SourceImageCollection
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollection
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollection
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SourceImageCollection
     */
    'project': number;
    /**
     * 
     * @type {MethodEnum}
     * @memberof SourceImageCollection
     */
    'method': MethodEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SourceImageCollection
     */
    'kwargs'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollection
     */
    'source_images': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollection
     */
    'source_image_count': string;
    /**
     * 
     * @type {Array<JobStatus>}
     * @memberof SourceImageCollection
     */
    'jobs': Array<JobStatus>;
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollection
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollection
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface SourceImageCollectionNested
 */
export interface SourceImageCollectionNested {
    /**
     * 
     * @type {number}
     * @memberof SourceImageCollectionNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollectionNested
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImageCollectionNested
     */
    'details': string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof SourceImageCollectionNested
     */
    'method': MethodEnum;
}


/**
 * 
 * @export
 * @interface SourceImageList
 */
export interface SourceImageList {
    /**
     * 
     * @type {number}
     * @memberof SourceImageList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SourceImageList
     */
    'details': string;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof SourceImageList
     */
    'deployment': DeploymentNested;
    /**
     * 
     * @type {EventNested}
     * @memberof SourceImageList
     */
    'event': EventNested;
    /**
     * Return the public URL for this image.  The base URL is determined by the deployment\'s data source and is cached on the source image. If the deployment\'s data source changes, the URLs for all source images will be updated.  @TODO use signed URLs if necessary. @TODO add support for thumbnail URLs here? @TODO consider if we ever need to access the original image directly!
     * @type {string}
     * @memberof SourceImageList
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImageList
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImageList
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImageList
     */
    'height'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImageList
     */
    'size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImageList
     */
    'detections_count': number;
    /**
     * 
     * @type {Array<CaptureDetections>}
     * @memberof SourceImageList
     */
    'detections': Array<CaptureDetections>;
}
/**
 * 
 * @export
 * @interface SourceImageNested
 */
export interface SourceImageNested {
    /**
     * 
     * @type {number}
     * @memberof SourceImageNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SourceImageNested
     */
    'details': string;
    /**
     * Return the public URL for this image.  The base URL is determined by the deployment\'s data source and is cached on the source image. If the deployment\'s data source changes, the URLs for all source images will be updated.  @TODO use signed URLs if necessary. @TODO add support for thumbnail URLs here? @TODO consider if we ever need to access the original image directly!
     * @type {string}
     * @memberof SourceImageNested
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof SourceImageNested
     */
    'width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImageNested
     */
    'height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SourceImageNested
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SourceImageNested
     */
    'event_id': number;
}
/**
 * 
 * @export
 * @interface SourceImageUpload
 */
export interface SourceImageUpload {
    /**
     * 
     * @type {number}
     * @memberof SourceImageUpload
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SourceImageUpload
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImageUpload
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof SourceImageUpload
     */
    'deployment': number;
    /**
     * 
     * @type {SourceImageNested}
     * @memberof SourceImageUpload
     */
    'source_image': SourceImageNested;
    /**
     * 
     * @type {number}
     * @memberof SourceImageUpload
     */
    'user': number;
    /**
     * 
     * @type {string}
     * @memberof SourceImageUpload
     */
    'created_at': string;
}
/**
 * * `CREATED` - CREATED * `PENDING` - PENDING * `STARTED` - STARTED * `SUCCESS` - SUCCESS * `FAILURE` - FAILURE * `RETRY` - RETRY * `CANCELING` - CANCELING * `REVOKED` - REVOKED * `RECEIVED` - RECEIVED * `UNKNOWN` - UNKNOWN
 * @export
 * @enum {string}
 */

export const StatusEnum = {
    Created: 'CREATED',
    Pending: 'PENDING',
    Started: 'STARTED',
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Retry: 'RETRY',
    Canceling: 'CANCELING',
    Revoked: 'REVOKED',
    Received: 'RECEIVED',
    Unknown: 'UNKNOWN'
} as const;

export type StatusEnum = typeof StatusEnum[keyof typeof StatusEnum];


/**
 * 
 * @export
 * @interface StorageSource
 */
export interface StorageSource {
    /**
     * 
     * @type {number}
     * @memberof StorageSource
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'bucket': string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'access_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'secret_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'endpoint_url': string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'public_base_url': string;
    /**
     * 
     * @type {number}
     * @memberof StorageSource
     */
    'project': number;
    /**
     * 
     * @type {number}
     * @memberof StorageSource
     */
    'total_files': number | null;
    /**
     * 
     * @type {number}
     * @memberof StorageSource
     */
    'total_size': number | null;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'last_checked': string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof StorageSource
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface StorageStatus
 */
export interface StorageStatus {
    /**
     * 
     * @type {string}
     * @memberof StorageStatus
     */
    'data_source': string;
}
/**
 * 
 * @export
 * @interface Taxon
 */
export interface Taxon {
    /**
     * 
     * @type {number}
     * @memberof Taxon
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Taxon
     */
    'name': string;
    /**
     * 
     * @type {RankEnum}
     * @memberof Taxon
     */
    'rank'?: RankEnum;
    /**
     * 
     * @type {TaxonNested}
     * @memberof Taxon
     */
    'parent': TaxonNested;
    /**
     * 
     * @type {number}
     * @memberof Taxon
     */
    'parent_id': number;
    /**
     * 
     * @type {string}
     * @memberof Taxon
     */
    'details': string;
    /**
     * 
     * @type {number}
     * @memberof Taxon
     */
    'occurrences_count': number;
    /**
     * 
     * @type {number}
     * @memberof Taxon
     */
    'detections_count': number;
    /**
     * 
     * @type {number}
     * @memberof Taxon
     */
    'events_count': number;
    /**
     * 
     * @type {Array<TaxonOccurrenceNested>}
     * @memberof Taxon
     */
    'occurrences': Array<TaxonOccurrenceNested>;
}


/**
 * 
 * @export
 * @interface TaxonDetections
 */
export interface TaxonDetections {
    /**
     * 
     * @type {number}
     * @memberof TaxonDetections
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaxonDetections
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof TaxonDetections
     */
    'timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaxonDetections
     */
    'details': string;
    /**
     * 
     * @type {number}
     * @memberof TaxonDetections
     */
    'width': number | null;
    /**
     * 
     * @type {number}
     * @memberof TaxonDetections
     */
    'height': number | null;
}
/**
 * 
 * @export
 * @interface TaxonList
 */
export interface TaxonList {
    /**
     * 
     * @type {number}
     * @memberof TaxonList
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaxonList
     */
    'name': string;
    /**
     * 
     * @type {RankEnum}
     * @memberof TaxonList
     */
    'rank'?: RankEnum;
    /**
     * 
     * @type {TaxonParentNested}
     * @memberof TaxonList
     */
    'parent': TaxonParentNested;
    /**
     * 
     * @type {string}
     * @memberof TaxonList
     */
    'details': string;
    /**
     * 
     * @type {number}
     * @memberof TaxonList
     */
    'occurrences_count': number;
    /**
     * 
     * @type {string}
     * @memberof TaxonList
     */
    'occurrences': string;
    /**
     * 
     * @type {string}
     * @memberof TaxonList
     */
    'occurrence_images': string;
    /**
     * 
     * @type {string}
     * @memberof TaxonList
     */
    'last_detected': string | null;
    /**
     * 
     * @type {number}
     * @memberof TaxonList
     */
    'best_determination_score': number | null;
    /**
     * 
     * @type {string}
     * @memberof TaxonList
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TaxonList
     */
    'updated_at': string;
}


/**
 * Simple Taxon serializer with 2 levels of nesting.
 * @export
 * @interface TaxonNested
 */
export interface TaxonNested {
    /**
     * 
     * @type {number}
     * @memberof TaxonNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaxonNested
     */
    'name': string;
    /**
     * 
     * @type {RankEnum}
     * @memberof TaxonNested
     */
    'rank'?: RankEnum;
    /**
     * 
     * @type {string}
     * @memberof TaxonNested
     */
    'details': string;
    /**
     * 
     * @type {TaxonParentNested}
     * @memberof TaxonNested
     */
    'parent': TaxonParentNested;
}


/**
 * 
 * @export
 * @interface TaxonNoParentNested
 */
export interface TaxonNoParentNested {
    /**
     * 
     * @type {number}
     * @memberof TaxonNoParentNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaxonNoParentNested
     */
    'name': string;
    /**
     * 
     * @type {RankEnum}
     * @memberof TaxonNoParentNested
     */
    'rank'?: RankEnum;
    /**
     * 
     * @type {string}
     * @memberof TaxonNoParentNested
     */
    'details': string;
}


/**
 * 
 * @export
 * @interface TaxonOccurrenceNested
 */
export interface TaxonOccurrenceNested {
    /**
     * 
     * @type {number}
     * @memberof TaxonOccurrenceNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaxonOccurrenceNested
     */
    'details': string;
    /**
     * 
     * @type {DeploymentNested}
     * @memberof TaxonOccurrenceNested
     */
    'deployment': DeploymentNested;
    /**
     * 
     * @type {EventNested}
     * @memberof TaxonOccurrenceNested
     */
    'event': EventNested;
    /**
     * 
     * @type {number}
     * @memberof TaxonOccurrenceNested
     */
    'determination_score'?: number | null;
    /**
     * 
     * @type {CaptureTaxon}
     * @memberof TaxonOccurrenceNested
     */
    'determination': CaptureTaxon;
    /**
     * 
     * @type {TaxonDetections}
     * @memberof TaxonOccurrenceNested
     */
    'best_detection': TaxonDetections;
    /**
     * 
     * @type {number}
     * @memberof TaxonOccurrenceNested
     */
    'detections_count': number | null;
    /**
     * 
     * @type {string}
     * @memberof TaxonOccurrenceNested
     */
    'duration': string | null;
    /**
     * If duration has been calculated by a query annotation, use that value otherwise call the duration() method to calculate it.
     * @type {string}
     * @memberof TaxonOccurrenceNested
     */
    'duration_label': string | null;
    /**
     * Return the timestamp of the first appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof TaxonOccurrenceNested
     */
    'first_appearance_timestamp': string | null;
    /**
     * Return the timestamp of the last appearance. ONLY if it has been added with a query annotation.
     * @type {string}
     * @memberof TaxonOccurrenceNested
     */
    'last_appearance_timestamp': string | null;
}
/**
 * 
 * @export
 * @interface TaxonParentNested
 */
export interface TaxonParentNested {
    /**
     * 
     * @type {number}
     * @memberof TaxonParentNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaxonParentNested
     */
    'name': string;
    /**
     * 
     * @type {RankEnum}
     * @memberof TaxonParentNested
     */
    'rank'?: RankEnum;
    /**
     * 
     * @type {string}
     * @memberof TaxonParentNested
     */
    'details': string;
    /**
     * 
     * @type {TaxonNoParentNested}
     * @memberof TaxonParentNested
     */
    'parent': TaxonNoParentNested;
}


/**
 * 
 * @export
 * @interface TokenCreate
 */
export interface TokenCreate {
    /**
     * 
     * @type {string}
     * @memberof TokenCreate
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenCreate
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'details': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'identifications': string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserNested
 */
export interface UserNested {
    /**
     * 
     * @type {number}
     * @memberof UserNested
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserNested
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNested
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserNested
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface UsernameResetConfirm
 */
export interface UsernameResetConfirm {
    /**
     * 
     * @type {string}
     * @memberof UsernameResetConfirm
     */
    'new_email': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to obtain user authentication token.
         * @param {TokenCreate} [tokenCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLoginCreate: async (tokenCreate?: TokenCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/auth/token/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to logout user (remove user authentication token).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLogoutCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/auth/token/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to obtain user authentication token.
         * @param {TokenCreate} [tokenCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenLoginCreate(tokenCreate?: TokenCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenLoginCreate(tokenCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authTokenLoginCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to logout user (remove user authentication token).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenLogoutCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenLogoutCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authTokenLogoutCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Use this endpoint to obtain user authentication token.
         * @param {TokenCreate} [tokenCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLoginCreate(tokenCreate?: TokenCreate, options?: any): AxiosPromise<TokenCreate> {
            return localVarFp.authTokenLoginCreate(tokenCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to logout user (remove user authentication token).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLogoutCreate(options?: any): AxiosPromise<void> {
            return localVarFp.authTokenLogoutCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Use this endpoint to obtain user authentication token.
     * @param {TokenCreate} [tokenCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenLoginCreate(tokenCreate?: TokenCreate, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenLoginCreate(tokenCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to logout user (remove user authentication token).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenLogoutCreate(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenLogoutCreate(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CapturesApi - axios parameter creator
 * @export
 */
export const CapturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a source image to a collection.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsAddCreate: async (id: number, sourceImageCollection: SourceImageCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesCollectionsAddCreate', 'id', id)
            // verify required parameter 'sourceImageCollection' is not null or undefined
            assertParamExists('capturesCollectionsAddCreate', 'sourceImageCollection', sourceImageCollection)
            const localVarPath = `/api/v2/captures/collections/{id}/add/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImageCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsCreate: async (sourceImageCollection: SourceImageCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceImageCollection' is not null or undefined
            assertParamExists('capturesCollectionsCreate', 'sourceImageCollection', sourceImageCollection)
            const localVarPath = `/api/v2/captures/collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImageCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesCollectionsDestroy', 'id', id)
            const localVarPath = `/api/v2/captures/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} [limit] Number of results to return per page.
         * @param {CapturesCollectionsListMethodEnum} [method] * &#x60;random&#x60; - random * &#x60;stratified_random&#x60; - stratified_random * &#x60;interval&#x60; - interval * &#x60;manual&#x60; - manual * &#x60;starred&#x60; - starred * &#x60;random_from_each_event&#x60; - random_from_each_event * &#x60;last_and_random_from_each_event&#x60; - last_and_random_from_each_event * &#x60;greatest_file_size_from_each_event&#x60; - greatest_file_size_from_each_event * &#x60;detections_only&#x60; - detections_only
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsList: async (limit?: number, method?: CapturesCollectionsListMethodEnum, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/captures/collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {PatchedSourceImageCollection} [patchedSourceImageCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsPartialUpdate: async (id: number, patchedSourceImageCollection?: PatchedSourceImageCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesCollectionsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/captures/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSourceImageCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Populate a collection with source images using the configured sampling method and arguments.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsPopulateCreate: async (id: number, sourceImageCollection: SourceImageCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesCollectionsPopulateCreate', 'id', id)
            // verify required parameter 'sourceImageCollection' is not null or undefined
            assertParamExists('capturesCollectionsPopulateCreate', 'sourceImageCollection', sourceImageCollection)
            const localVarPath = `/api/v2/captures/collections/{id}/populate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImageCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a source image from a collection.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsRemoveCreate: async (id: number, sourceImageCollection: SourceImageCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesCollectionsRemoveCreate', 'id', id)
            // verify required parameter 'sourceImageCollection' is not null or undefined
            assertParamExists('capturesCollectionsRemoveCreate', 'sourceImageCollection', sourceImageCollection)
            const localVarPath = `/api/v2/captures/collections/{id}/remove/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImageCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesCollectionsRetrieve', 'id', id)
            const localVarPath = `/api/v2/captures/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsUpdate: async (id: number, sourceImageCollection: SourceImageCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesCollectionsUpdate', 'id', id)
            // verify required parameter 'sourceImageCollection' is not null or undefined
            assertParamExists('capturesCollectionsUpdate', 'sourceImageCollection', sourceImageCollection)
            const localVarPath = `/api/v2/captures/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImageCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCreate: async (sourceImage?: SourceImage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/captures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesDestroy', 'id', id)
            const localVarPath = `/api/v2/captures/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {Array<number>} [collections] 
         * @param {number} [deployment] 
         * @param {number} [deploymentProject] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesList: async (collections?: Array<number>, deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/captures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (collections) {
                localVarQueryParameter['collections'] = collections;
            }

            if (deployment !== undefined) {
                localVarQueryParameter['deployment'] = deployment;
            }

            if (deploymentProject !== undefined) {
                localVarQueryParameter['deployment__project'] = deploymentProject;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {PatchedSourceImage} [patchedSourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesPartialUpdate: async (id: number, patchedSourceImage?: PatchedSourceImage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/captures/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSourceImage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesRetrieve', 'id', id)
            const localVarPath = `/api/v2/captures/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a source image to the project\'s starred images collection.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesStarCreate: async (id: number, sourceImage?: SourceImage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesStarCreate', 'id', id)
            const localVarPath = `/api/v2/captures/{id}/star/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a source image from the project\'s starred images collection.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUnstarCreate: async (id: number, sourceImage?: SourceImage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesUnstarCreate', 'id', id)
            const localVarPath = `/api/v2/captures/{id}/unstar/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUpdate: async (id: number, sourceImage?: SourceImage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesUpdate', 'id', id)
            const localVarPath = `/api/v2/captures/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for uploading images.
         * @param {SourceImageUpload} sourceImageUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadCreate: async (sourceImageUpload: SourceImageUpload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceImageUpload' is not null or undefined
            assertParamExists('capturesUploadCreate', 'sourceImageUpload', sourceImageUpload)
            const localVarPath = `/api/v2/captures/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImageUpload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesUploadDestroy', 'id', id)
            const localVarPath = `/api/v2/captures/upload/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for uploading images.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadList: async (limit?: number, offset?: number, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/captures/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {PatchedSourceImageUpload} [patchedSourceImageUpload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadPartialUpdate: async (id: number, patchedSourceImageUpload?: PatchedSourceImageUpload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesUploadPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/captures/upload/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSourceImageUpload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesUploadRetrieve', 'id', id)
            const localVarPath = `/api/v2/captures/upload/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {SourceImageUpload} sourceImageUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadUpdate: async (id: number, sourceImageUpload: SourceImageUpload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturesUploadUpdate', 'id', id)
            // verify required parameter 'sourceImageUpload' is not null or undefined
            assertParamExists('capturesUploadUpdate', 'sourceImageUpload', sourceImageUpload)
            const localVarPath = `/api/v2/captures/upload/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceImageUpload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CapturesApi - functional programming interface
 * @export
 */
export const CapturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CapturesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a source image to a collection.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsAddCreate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsAddCreate(id, sourceImageCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsAddCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsCreate(sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsCreate(sourceImageCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} [limit] Number of results to return per page.
         * @param {CapturesCollectionsListMethodEnum} [method] * &#x60;random&#x60; - random * &#x60;stratified_random&#x60; - stratified_random * &#x60;interval&#x60; - interval * &#x60;manual&#x60; - manual * &#x60;starred&#x60; - starred * &#x60;random_from_each_event&#x60; - random_from_each_event * &#x60;last_and_random_from_each_event&#x60; - last_and_random_from_each_event * &#x60;greatest_file_size_from_each_event&#x60; - greatest_file_size_from_each_event * &#x60;detections_only&#x60; - detections_only
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsList(limit?: number, method?: CapturesCollectionsListMethodEnum, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSourceImageCollectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsList(limit, method, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {PatchedSourceImageCollection} [patchedSourceImageCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsPartialUpdate(id: number, patchedSourceImageCollection?: PatchedSourceImageCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsPartialUpdate(id, patchedSourceImageCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Populate a collection with source images using the configured sampling method and arguments.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsPopulateCreate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsPopulateCreate(id, sourceImageCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsPopulateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a source image from a collection.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsRemoveCreate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsRemoveCreate(id, sourceImageCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsRemoveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCollectionsUpdate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCollectionsUpdate(id, sourceImageCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCollectionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesCreate(sourceImage?: SourceImage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesCreate(sourceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {Array<number>} [collections] 
         * @param {number} [deployment] 
         * @param {number} [deploymentProject] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesList(collections?: Array<number>, deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSourceImageListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesList(collections, deployment, deploymentProject, event, limit, offset, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {PatchedSourceImage} [patchedSourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesPartialUpdate(id: number, patchedSourceImage?: PatchedSourceImage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesPartialUpdate(id, patchedSourceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a source image to the project\'s starred images collection.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesStarCreate(id: number, sourceImage?: SourceImage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesStarCreate(id, sourceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesStarCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a source image from the project\'s starred images collection.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUnstarCreate(id: number, sourceImage?: SourceImage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUnstarCreate(id, sourceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUnstarCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUpdate(id: number, sourceImage?: SourceImage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUpdate(id, sourceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for uploading images.
         * @param {SourceImageUpload} sourceImageUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUploadCreate(sourceImageUpload: SourceImageUpload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUploadCreate(sourceImageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUploadCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUploadDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUploadDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUploadDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for uploading images.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUploadList(limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSourceImageUploadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUploadList(limit, offset, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUploadList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {PatchedSourceImageUpload} [patchedSourceImageUpload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUploadPartialUpdate(id: number, patchedSourceImageUpload?: PatchedSourceImageUpload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUploadPartialUpdate(id, patchedSourceImageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUploadPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUploadRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUploadRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUploadRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {SourceImageUpload} sourceImageUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturesUploadUpdate(id: number, sourceImageUpload: SourceImageUpload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceImageUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturesUploadUpdate(id, sourceImageUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CapturesApi.capturesUploadUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CapturesApi - factory interface
 * @export
 */
export const CapturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CapturesApiFp(configuration)
    return {
        /**
         * Add a source image to a collection.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsAddCreate(id: number, sourceImageCollection: SourceImageCollection, options?: any): AxiosPromise<SourceImageCollection> {
            return localVarFp.capturesCollectionsAddCreate(id, sourceImageCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsCreate(sourceImageCollection: SourceImageCollection, options?: any): AxiosPromise<SourceImageCollection> {
            return localVarFp.capturesCollectionsCreate(sourceImageCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.capturesCollectionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} [limit] Number of results to return per page.
         * @param {CapturesCollectionsListMethodEnum} [method] * &#x60;random&#x60; - random * &#x60;stratified_random&#x60; - stratified_random * &#x60;interval&#x60; - interval * &#x60;manual&#x60; - manual * &#x60;starred&#x60; - starred * &#x60;random_from_each_event&#x60; - random_from_each_event * &#x60;last_and_random_from_each_event&#x60; - last_and_random_from_each_event * &#x60;greatest_file_size_from_each_event&#x60; - greatest_file_size_from_each_event * &#x60;detections_only&#x60; - detections_only
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsList(limit?: number, method?: CapturesCollectionsListMethodEnum, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedSourceImageCollectionList> {
            return localVarFp.capturesCollectionsList(limit, method, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {PatchedSourceImageCollection} [patchedSourceImageCollection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsPartialUpdate(id: number, patchedSourceImageCollection?: PatchedSourceImageCollection, options?: any): AxiosPromise<SourceImageCollection> {
            return localVarFp.capturesCollectionsPartialUpdate(id, patchedSourceImageCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * Populate a collection with source images using the configured sampling method and arguments.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsPopulateCreate(id: number, sourceImageCollection: SourceImageCollection, options?: any): AxiosPromise<SourceImageCollection> {
            return localVarFp.capturesCollectionsPopulateCreate(id, sourceImageCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a source image from a collection.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsRemoveCreate(id: number, sourceImageCollection: SourceImageCollection, options?: any): AxiosPromise<SourceImageCollection> {
            return localVarFp.capturesCollectionsRemoveCreate(id, sourceImageCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsRetrieve(id: number, options?: any): AxiosPromise<SourceImageCollection> {
            return localVarFp.capturesCollectionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for viewing collections or samples of source images.
         * @param {number} id A unique integer value identifying this source image collection.
         * @param {SourceImageCollection} sourceImageCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCollectionsUpdate(id: number, sourceImageCollection: SourceImageCollection, options?: any): AxiosPromise<SourceImageCollection> {
            return localVarFp.capturesCollectionsUpdate(id, sourceImageCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesCreate(sourceImage?: SourceImage, options?: any): AxiosPromise<SourceImage> {
            return localVarFp.capturesCreate(sourceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.capturesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {Array<number>} [collections] 
         * @param {number} [deployment] 
         * @param {number} [deploymentProject] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesList(collections?: Array<number>, deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options?: any): AxiosPromise<PaginatedSourceImageListList> {
            return localVarFp.capturesList(collections, deployment, deploymentProject, event, limit, offset, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {PatchedSourceImage} [patchedSourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesPartialUpdate(id: number, patchedSourceImage?: PatchedSourceImage, options?: any): AxiosPromise<SourceImage> {
            return localVarFp.capturesPartialUpdate(id, patchedSourceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesRetrieve(id: number, options?: any): AxiosPromise<SourceImage> {
            return localVarFp.capturesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a source image to the project\'s starred images collection.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesStarCreate(id: number, sourceImage?: SourceImage, options?: any): AxiosPromise<SourceImage> {
            return localVarFp.capturesStarCreate(id, sourceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a source image from the project\'s starred images collection.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUnstarCreate(id: number, sourceImage?: SourceImage, options?: any): AxiosPromise<SourceImage> {
            return localVarFp.capturesUnstarCreate(id, sourceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows captures from monitoring sessions to be viewed or edited.
         * @param {number} id A unique integer value identifying this source image.
         * @param {SourceImage} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUpdate(id: number, sourceImage?: SourceImage, options?: any): AxiosPromise<SourceImage> {
            return localVarFp.capturesUpdate(id, sourceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for uploading images.
         * @param {SourceImageUpload} sourceImageUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadCreate(sourceImageUpload: SourceImageUpload, options?: any): AxiosPromise<SourceImageUpload> {
            return localVarFp.capturesUploadCreate(sourceImageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.capturesUploadDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for uploading images.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadList(limit?: number, offset?: number, ordering?: string, search?: string, options?: any): AxiosPromise<PaginatedSourceImageUploadList> {
            return localVarFp.capturesUploadList(limit, offset, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {PatchedSourceImageUpload} [patchedSourceImageUpload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadPartialUpdate(id: number, patchedSourceImageUpload?: PatchedSourceImageUpload, options?: any): AxiosPromise<SourceImageUpload> {
            return localVarFp.capturesUploadPartialUpdate(id, patchedSourceImageUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadRetrieve(id: number, options?: any): AxiosPromise<SourceImageUpload> {
            return localVarFp.capturesUploadRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for uploading images.
         * @param {number} id A unique integer value identifying this source image upload.
         * @param {SourceImageUpload} sourceImageUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturesUploadUpdate(id: number, sourceImageUpload: SourceImageUpload, options?: any): AxiosPromise<SourceImageUpload> {
            return localVarFp.capturesUploadUpdate(id, sourceImageUpload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CapturesApi - object-oriented interface
 * @export
 * @class CapturesApi
 * @extends {BaseAPI}
 */
export class CapturesApi extends BaseAPI {
    /**
     * Add a source image to a collection.
     * @param {number} id A unique integer value identifying this source image collection.
     * @param {SourceImageCollection} sourceImageCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsAddCreate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsAddCreate(id, sourceImageCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for viewing collections or samples of source images.
     * @param {SourceImageCollection} sourceImageCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsCreate(sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsCreate(sourceImageCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for viewing collections or samples of source images.
     * @param {number} id A unique integer value identifying this source image collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for viewing collections or samples of source images.
     * @param {number} [limit] Number of results to return per page.
     * @param {CapturesCollectionsListMethodEnum} [method] * &#x60;random&#x60; - random * &#x60;stratified_random&#x60; - stratified_random * &#x60;interval&#x60; - interval * &#x60;manual&#x60; - manual * &#x60;starred&#x60; - starred * &#x60;random_from_each_event&#x60; - random_from_each_event * &#x60;last_and_random_from_each_event&#x60; - last_and_random_from_each_event * &#x60;greatest_file_size_from_each_event&#x60; - greatest_file_size_from_each_event * &#x60;detections_only&#x60; - detections_only
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsList(limit?: number, method?: CapturesCollectionsListMethodEnum, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsList(limit, method, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for viewing collections or samples of source images.
     * @param {number} id A unique integer value identifying this source image collection.
     * @param {PatchedSourceImageCollection} [patchedSourceImageCollection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsPartialUpdate(id: number, patchedSourceImageCollection?: PatchedSourceImageCollection, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsPartialUpdate(id, patchedSourceImageCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Populate a collection with source images using the configured sampling method and arguments.
     * @param {number} id A unique integer value identifying this source image collection.
     * @param {SourceImageCollection} sourceImageCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsPopulateCreate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsPopulateCreate(id, sourceImageCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a source image from a collection.
     * @param {number} id A unique integer value identifying this source image collection.
     * @param {SourceImageCollection} sourceImageCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsRemoveCreate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsRemoveCreate(id, sourceImageCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for viewing collections or samples of source images.
     * @param {number} id A unique integer value identifying this source image collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for viewing collections or samples of source images.
     * @param {number} id A unique integer value identifying this source image collection.
     * @param {SourceImageCollection} sourceImageCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCollectionsUpdate(id: number, sourceImageCollection: SourceImageCollection, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCollectionsUpdate(id, sourceImageCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows captures from monitoring sessions to be viewed or edited.
     * @param {SourceImage} [sourceImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesCreate(sourceImage?: SourceImage, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesCreate(sourceImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows captures from monitoring sessions to be viewed or edited.
     * @param {number} id A unique integer value identifying this source image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesDestroy(id: number, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows captures from monitoring sessions to be viewed or edited.
     * @param {Array<number>} [collections] 
     * @param {number} [deployment] 
     * @param {number} [deploymentProject] 
     * @param {number} [event] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesList(collections?: Array<number>, deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesList(collections, deployment, deploymentProject, event, limit, offset, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows captures from monitoring sessions to be viewed or edited.
     * @param {number} id A unique integer value identifying this source image.
     * @param {PatchedSourceImage} [patchedSourceImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesPartialUpdate(id: number, patchedSourceImage?: PatchedSourceImage, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesPartialUpdate(id, patchedSourceImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows captures from monitoring sessions to be viewed or edited.
     * @param {number} id A unique integer value identifying this source image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a source image to the project\'s starred images collection.
     * @param {number} id A unique integer value identifying this source image.
     * @param {SourceImage} [sourceImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesStarCreate(id: number, sourceImage?: SourceImage, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesStarCreate(id, sourceImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a source image from the project\'s starred images collection.
     * @param {number} id A unique integer value identifying this source image.
     * @param {SourceImage} [sourceImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUnstarCreate(id: number, sourceImage?: SourceImage, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUnstarCreate(id, sourceImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows captures from monitoring sessions to be viewed or edited.
     * @param {number} id A unique integer value identifying this source image.
     * @param {SourceImage} [sourceImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUpdate(id: number, sourceImage?: SourceImage, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUpdate(id, sourceImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for uploading images.
     * @param {SourceImageUpload} sourceImageUpload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUploadCreate(sourceImageUpload: SourceImageUpload, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUploadCreate(sourceImageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for uploading images.
     * @param {number} id A unique integer value identifying this source image upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUploadDestroy(id: number, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUploadDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for uploading images.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUploadList(limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUploadList(limit, offset, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for uploading images.
     * @param {number} id A unique integer value identifying this source image upload.
     * @param {PatchedSourceImageUpload} [patchedSourceImageUpload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUploadPartialUpdate(id: number, patchedSourceImageUpload?: PatchedSourceImageUpload, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUploadPartialUpdate(id, patchedSourceImageUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for uploading images.
     * @param {number} id A unique integer value identifying this source image upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUploadRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUploadRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for uploading images.
     * @param {number} id A unique integer value identifying this source image upload.
     * @param {SourceImageUpload} sourceImageUpload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public capturesUploadUpdate(id: number, sourceImageUpload: SourceImageUpload, options?: RawAxiosRequestConfig) {
        return CapturesApiFp(this.configuration).capturesUploadUpdate(id, sourceImageUpload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CapturesCollectionsListMethodEnum = {
    DetectionsOnly: 'detections_only',
    GreatestFileSizeFromEachEvent: 'greatest_file_size_from_each_event',
    Interval: 'interval',
    LastAndRandomFromEachEvent: 'last_and_random_from_each_event',
    Manual: 'manual',
    Random: 'random',
    RandomFromEachEvent: 'random_from_each_event',
    Starred: 'starred',
    StratifiedRandom: 'stratified_random'
} as const;
export type CapturesCollectionsListMethodEnum = typeof CapturesCollectionsListMethodEnum[keyof typeof CapturesCollectionsListMethodEnum];


/**
 * ClassificationsApi - axios parameter creator
 * @export
 */
export const ClassificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {Classification} [classification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsCreate: async (classification?: Classification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/classifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classificationsDestroy', 'id', id)
            const localVarPath = `/api/v2/classifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} [algorithm] 
         * @param {number} [detection] 
         * @param {number} [detectionOccurrence] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [taxon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsList: async (algorithm?: number, detection?: number, detectionOccurrence?: number, limit?: number, offset?: number, ordering?: string, search?: string, taxon?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/classifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (algorithm !== undefined) {
                localVarQueryParameter['algorithm'] = algorithm;
            }

            if (detection !== undefined) {
                localVarQueryParameter['detection'] = detection;
            }

            if (detectionOccurrence !== undefined) {
                localVarQueryParameter['detection__occurrence'] = detectionOccurrence;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (taxon !== undefined) {
                localVarQueryParameter['taxon'] = taxon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {PatchedClassification} [patchedClassification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsPartialUpdate: async (id: number, patchedClassification?: PatchedClassification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classificationsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/classifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClassification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classificationsRetrieve', 'id', id)
            const localVarPath = `/api/v2/classifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {Classification} [classification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsUpdate: async (id: number, classification?: Classification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classificationsUpdate', 'id', id)
            const localVarPath = `/api/v2/classifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassificationsApi - functional programming interface
 * @export
 */
export const ClassificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {Classification} [classification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationsCreate(classification?: Classification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Classification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationsCreate(classification, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassificationsApi.classificationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassificationsApi.classificationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} [algorithm] 
         * @param {number} [detection] 
         * @param {number} [detectionOccurrence] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [taxon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationsList(algorithm?: number, detection?: number, detectionOccurrence?: number, limit?: number, offset?: number, ordering?: string, search?: string, taxon?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedClassificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationsList(algorithm, detection, detectionOccurrence, limit, offset, ordering, search, taxon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassificationsApi.classificationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {PatchedClassification} [patchedClassification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationsPartialUpdate(id: number, patchedClassification?: PatchedClassification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Classification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationsPartialUpdate(id, patchedClassification, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassificationsApi.classificationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Classification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassificationsApi.classificationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {Classification} [classification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationsUpdate(id: number, classification?: Classification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Classification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationsUpdate(id, classification, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassificationsApi.classificationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassificationsApi - factory interface
 * @export
 */
export const ClassificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassificationsApiFp(configuration)
    return {
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {Classification} [classification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsCreate(classification?: Classification, options?: any): AxiosPromise<Classification> {
            return localVarFp.classificationsCreate(classification, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.classificationsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} [algorithm] 
         * @param {number} [detection] 
         * @param {number} [detectionOccurrence] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [taxon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsList(algorithm?: number, detection?: number, detectionOccurrence?: number, limit?: number, offset?: number, ordering?: string, search?: string, taxon?: number, options?: any): AxiosPromise<PaginatedClassificationList> {
            return localVarFp.classificationsList(algorithm, detection, detectionOccurrence, limit, offset, ordering, search, taxon, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {PatchedClassification} [patchedClassification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsPartialUpdate(id: number, patchedClassification?: PatchedClassification, options?: any): AxiosPromise<Classification> {
            return localVarFp.classificationsPartialUpdate(id, patchedClassification, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsRetrieve(id: number, options?: any): AxiosPromise<Classification> {
            return localVarFp.classificationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for viewing and adding classification results from a model.
         * @param {number} id A unique integer value identifying this classification.
         * @param {Classification} [classification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationsUpdate(id: number, classification?: Classification, options?: any): AxiosPromise<Classification> {
            return localVarFp.classificationsUpdate(id, classification, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassificationsApi - object-oriented interface
 * @export
 * @class ClassificationsApi
 * @extends {BaseAPI}
 */
export class ClassificationsApi extends BaseAPI {
    /**
     * API endpoint for viewing and adding classification results from a model.
     * @param {Classification} [classification] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationsApi
     */
    public classificationsCreate(classification?: Classification, options?: RawAxiosRequestConfig) {
        return ClassificationsApiFp(this.configuration).classificationsCreate(classification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for viewing and adding classification results from a model.
     * @param {number} id A unique integer value identifying this classification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationsApi
     */
    public classificationsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return ClassificationsApiFp(this.configuration).classificationsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for viewing and adding classification results from a model.
     * @param {number} [algorithm] 
     * @param {number} [detection] 
     * @param {number} [detectionOccurrence] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {number} [taxon] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationsApi
     */
    public classificationsList(algorithm?: number, detection?: number, detectionOccurrence?: number, limit?: number, offset?: number, ordering?: string, search?: string, taxon?: number, options?: RawAxiosRequestConfig) {
        return ClassificationsApiFp(this.configuration).classificationsList(algorithm, detection, detectionOccurrence, limit, offset, ordering, search, taxon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for viewing and adding classification results from a model.
     * @param {number} id A unique integer value identifying this classification.
     * @param {PatchedClassification} [patchedClassification] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationsApi
     */
    public classificationsPartialUpdate(id: number, patchedClassification?: PatchedClassification, options?: RawAxiosRequestConfig) {
        return ClassificationsApiFp(this.configuration).classificationsPartialUpdate(id, patchedClassification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for viewing and adding classification results from a model.
     * @param {number} id A unique integer value identifying this classification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationsApi
     */
    public classificationsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return ClassificationsApiFp(this.configuration).classificationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for viewing and adding classification results from a model.
     * @param {number} id A unique integer value identifying this classification.
     * @param {Classification} [classification] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationsApi
     */
    public classificationsUpdate(id: number, classification?: Classification, options?: RawAxiosRequestConfig) {
        return ClassificationsApiFp(this.configuration).classificationsUpdate(id, classification, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentsApi - axios parameter creator
 * @export
 */
export const DeploymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {Deployment} deployment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsCreate: async (deployment: Deployment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deployment' is not null or undefined
            assertParamExists('deploymentsCreate', 'deployment', deployment)
            const localVarPath = `/api/v2/deployments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsDestroy', 'id', id)
            const localVarPath = `/api/v2/deployments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesCreate: async (device: Device, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('deploymentsDevicesCreate', 'device', device)
            const localVarPath = `/api/v2/deployments/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsDevicesDestroy', 'id', id)
            const localVarPath = `/api/v2/deployments/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesList: async (deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/deployments/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployments) {
                localVarQueryParameter['deployments'] = deployments;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {PatchedDevice} [patchedDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesPartialUpdate: async (id: number, patchedDevice?: PatchedDevice, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsDevicesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/deployments/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDevice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsDevicesRetrieve', 'id', id)
            const localVarPath = `/api/v2/deployments/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesUpdate: async (id: number, device: Device, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsDevicesUpdate', 'id', id)
            // verify required parameter 'device' is not null or undefined
            assertParamExists('deploymentsDevicesUpdate', 'device', device)
            const localVarPath = `/api/v2/deployments/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsList: async (limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/deployments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {PatchedDeployment} [patchedDeployment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsPartialUpdate: async (id: number, patchedDeployment?: PatchedDeployment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/deployments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDeployment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsRetrieve', 'id', id)
            const localVarPath = `/api/v2/deployments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesCreate: async (site: Site, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('deploymentsSitesCreate', 'site', site)
            const localVarPath = `/api/v2/deployments/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsSitesDestroy', 'id', id)
            const localVarPath = `/api/v2/deployments/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesList: async (deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/deployments/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployments) {
                localVarQueryParameter['deployments'] = deployments;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {PatchedSite} [patchedSite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesPartialUpdate: async (id: number, patchedSite?: PatchedSite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsSitesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/deployments/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsSitesRetrieve', 'id', id)
            const localVarPath = `/api/v2/deployments/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesUpdate: async (id: number, site: Site, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsSitesUpdate', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('deploymentsSitesUpdate', 'site', site)
            const localVarPath = `/api/v2/deployments/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {Deployment} deployment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsUpdate: async (id: number, deployment: Deployment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsUpdate', 'id', id)
            // verify required parameter 'deployment' is not null or undefined
            assertParamExists('deploymentsUpdate', 'deployment', deployment)
            const localVarPath = `/api/v2/deployments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentsApi - functional programming interface
 * @export
 */
export const DeploymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {Deployment} deployment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsCreate(deployment: Deployment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsCreate(deployment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDevicesCreate(device: Device, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDevicesCreate(device, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDevicesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDevicesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDevicesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDevicesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDevicesList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeviceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDevicesList(deployments, limit, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDevicesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {PatchedDevice} [patchedDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDevicesPartialUpdate(id: number, patchedDevice?: PatchedDevice, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDevicesPartialUpdate(id, patchedDevice, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDevicesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDevicesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDevicesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDevicesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDevicesUpdate(id: number, device: Device, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDevicesUpdate(id, device, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDevicesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsList(limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeploymentListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsList(limit, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {PatchedDeployment} [patchedDeployment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsPartialUpdate(id: number, patchedDeployment?: PatchedDeployment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsPartialUpdate(id, patchedDeployment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsSitesCreate(site: Site, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsSitesCreate(site, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsSitesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsSitesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsSitesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsSitesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsSitesList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSiteList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsSitesList(deployments, limit, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsSitesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {PatchedSite} [patchedSite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsSitesPartialUpdate(id: number, patchedSite?: PatchedSite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsSitesPartialUpdate(id, patchedSite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsSitesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsSitesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsSitesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsSitesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsSitesUpdate(id: number, site: Site, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsSitesUpdate(id, site, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsSitesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {Deployment} deployment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsUpdate(id: number, deployment: Deployment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsUpdate(id, deployment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentsApi - factory interface
 * @export
 */
export const DeploymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentsApiFp(configuration)
    return {
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {Deployment} deployment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsCreate(deployment: Deployment, options?: any): AxiosPromise<Deployment> {
            return localVarFp.deploymentsCreate(deployment, options).then((request) => request(axios, basePath));
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deploymentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesCreate(device: Device, options?: any): AxiosPromise<Device> {
            return localVarFp.deploymentsDevicesCreate(device, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deploymentsDevicesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedDeviceList> {
            return localVarFp.deploymentsDevicesList(deployments, limit, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {PatchedDevice} [patchedDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesPartialUpdate(id: number, patchedDevice?: PatchedDevice, options?: any): AxiosPromise<Device> {
            return localVarFp.deploymentsDevicesPartialUpdate(id, patchedDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesRetrieve(id: number, options?: any): AxiosPromise<Device> {
            return localVarFp.deploymentsDevicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows devices to be viewed or edited.
         * @param {number} id A unique integer value identifying this Device Configuration.
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDevicesUpdate(id: number, device: Device, options?: any): AxiosPromise<Device> {
            return localVarFp.deploymentsDevicesUpdate(id, device, options).then((request) => request(axios, basePath));
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsList(limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedDeploymentListList> {
            return localVarFp.deploymentsList(limit, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {PatchedDeployment} [patchedDeployment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsPartialUpdate(id: number, patchedDeployment?: PatchedDeployment, options?: any): AxiosPromise<Deployment> {
            return localVarFp.deploymentsPartialUpdate(id, patchedDeployment, options).then((request) => request(axios, basePath));
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsRetrieve(id: number, options?: any): AxiosPromise<Deployment> {
            return localVarFp.deploymentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesCreate(site: Site, options?: any): AxiosPromise<Site> {
            return localVarFp.deploymentsSitesCreate(site, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deploymentsSitesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedSiteList> {
            return localVarFp.deploymentsSitesList(deployments, limit, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {PatchedSite} [patchedSite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesPartialUpdate(id: number, patchedSite?: PatchedSite, options?: any): AxiosPromise<Site> {
            return localVarFp.deploymentsSitesPartialUpdate(id, patchedSite, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesRetrieve(id: number, options?: any): AxiosPromise<Site> {
            return localVarFp.deploymentsSitesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows sites to be viewed or edited.
         * @param {number} id A unique integer value identifying this Research Site.
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsSitesUpdate(id: number, site: Site, options?: any): AxiosPromise<Site> {
            return localVarFp.deploymentsSitesUpdate(id, site, options).then((request) => request(axios, basePath));
        },
        /**
         * A model viewset that uses different serializers for the list and detail views.
         * @param {number} id A unique integer value identifying this deployment.
         * @param {Deployment} deployment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsUpdate(id: number, deployment: Deployment, options?: any): AxiosPromise<Deployment> {
            return localVarFp.deploymentsUpdate(id, deployment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentsApi - object-oriented interface
 * @export
 * @class DeploymentsApi
 * @extends {BaseAPI}
 */
export class DeploymentsApi extends BaseAPI {
    /**
     * A model viewset that uses different serializers for the list and detail views.
     * @param {Deployment} deployment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsCreate(deployment: Deployment, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsCreate(deployment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A model viewset that uses different serializers for the list and detail views.
     * @param {number} id A unique integer value identifying this deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows devices to be viewed or edited.
     * @param {Device} device 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDevicesCreate(device: Device, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDevicesCreate(device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows devices to be viewed or edited.
     * @param {number} id A unique integer value identifying this Device Configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDevicesDestroy(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDevicesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows devices to be viewed or edited.
     * @param {Array<number>} [deployments] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDevicesList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDevicesList(deployments, limit, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows devices to be viewed or edited.
     * @param {number} id A unique integer value identifying this Device Configuration.
     * @param {PatchedDevice} [patchedDevice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDevicesPartialUpdate(id: number, patchedDevice?: PatchedDevice, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDevicesPartialUpdate(id, patchedDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows devices to be viewed or edited.
     * @param {number} id A unique integer value identifying this Device Configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDevicesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDevicesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows devices to be viewed or edited.
     * @param {number} id A unique integer value identifying this Device Configuration.
     * @param {Device} device 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDevicesUpdate(id: number, device: Device, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDevicesUpdate(id, device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A model viewset that uses different serializers for the list and detail views.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsList(limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsList(limit, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A model viewset that uses different serializers for the list and detail views.
     * @param {number} id A unique integer value identifying this deployment.
     * @param {PatchedDeployment} [patchedDeployment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsPartialUpdate(id: number, patchedDeployment?: PatchedDeployment, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsPartialUpdate(id, patchedDeployment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A model viewset that uses different serializers for the list and detail views.
     * @param {number} id A unique integer value identifying this deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows sites to be viewed or edited.
     * @param {Site} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsSitesCreate(site: Site, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsSitesCreate(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows sites to be viewed or edited.
     * @param {number} id A unique integer value identifying this Research Site.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsSitesDestroy(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsSitesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows sites to be viewed or edited.
     * @param {Array<number>} [deployments] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsSitesList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsSitesList(deployments, limit, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows sites to be viewed or edited.
     * @param {number} id A unique integer value identifying this Research Site.
     * @param {PatchedSite} [patchedSite] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsSitesPartialUpdate(id: number, patchedSite?: PatchedSite, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsSitesPartialUpdate(id, patchedSite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows sites to be viewed or edited.
     * @param {number} id A unique integer value identifying this Research Site.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsSitesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsSitesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows sites to be viewed or edited.
     * @param {number} id A unique integer value identifying this Research Site.
     * @param {Site} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsSitesUpdate(id: number, site: Site, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsSitesUpdate(id, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A model viewset that uses different serializers for the list and detail views.
     * @param {number} id A unique integer value identifying this deployment.
     * @param {Deployment} deployment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsUpdate(id: number, deployment: Deployment, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsUpdate(id, deployment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DetectionsApi - axios parameter creator
 * @export
 */
export const DetectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {Detection} detection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsCreate: async (detection: Detection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'detection' is not null or undefined
            assertParamExists('detectionsCreate', 'detection', detection)
            const localVarPath = `/api/v2/detections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detectionsDestroy', 'id', id)
            const localVarPath = `/api/v2/detections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} [detectionAlgorithm] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsList: async (detectionAlgorithm?: number, limit?: number, offset?: number, ordering?: string, search?: string, sourceImage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/detections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (detectionAlgorithm !== undefined) {
                localVarQueryParameter['detection_algorithm'] = detectionAlgorithm;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sourceImage !== undefined) {
                localVarQueryParameter['source_image'] = sourceImage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {PatchedDetection} [patchedDetection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsPartialUpdate: async (id: number, patchedDetection?: PatchedDetection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detectionsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/detections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDetection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detectionsRetrieve', 'id', id)
            const localVarPath = `/api/v2/detections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {Detection} detection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsUpdate: async (id: number, detection: Detection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detectionsUpdate', 'id', id)
            // verify required parameter 'detection' is not null or undefined
            assertParamExists('detectionsUpdate', 'detection', detection)
            const localVarPath = `/api/v2/detections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(detection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DetectionsApi - functional programming interface
 * @export
 */
export const DetectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DetectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {Detection} detection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectionsCreate(detection: Detection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Detection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectionsCreate(detection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetectionsApi.detectionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectionsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetectionsApi.detectionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} [detectionAlgorithm] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectionsList(detectionAlgorithm?: number, limit?: number, offset?: number, ordering?: string, search?: string, sourceImage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDetectionListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectionsList(detectionAlgorithm, limit, offset, ordering, search, sourceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetectionsApi.detectionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {PatchedDetection} [patchedDetection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectionsPartialUpdate(id: number, patchedDetection?: PatchedDetection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Detection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectionsPartialUpdate(id, patchedDetection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetectionsApi.detectionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Detection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetectionsApi.detectionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {Detection} detection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectionsUpdate(id: number, detection: Detection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Detection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectionsUpdate(id, detection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DetectionsApi.detectionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DetectionsApi - factory interface
 * @export
 */
export const DetectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DetectionsApiFp(configuration)
    return {
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {Detection} detection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsCreate(detection: Detection, options?: any): AxiosPromise<Detection> {
            return localVarFp.detectionsCreate(detection, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.detectionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} [detectionAlgorithm] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [sourceImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsList(detectionAlgorithm?: number, limit?: number, offset?: number, ordering?: string, search?: string, sourceImage?: number, options?: any): AxiosPromise<PaginatedDetectionListList> {
            return localVarFp.detectionsList(detectionAlgorithm, limit, offset, ordering, search, sourceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {PatchedDetection} [patchedDetection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsPartialUpdate(id: number, patchedDetection?: PatchedDetection, options?: any): AxiosPromise<Detection> {
            return localVarFp.detectionsPartialUpdate(id, patchedDetection, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsRetrieve(id: number, options?: any): AxiosPromise<Detection> {
            return localVarFp.detectionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows detections to be viewed or edited.
         * @param {number} id A unique integer value identifying this detection.
         * @param {Detection} detection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectionsUpdate(id: number, detection: Detection, options?: any): AxiosPromise<Detection> {
            return localVarFp.detectionsUpdate(id, detection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DetectionsApi - object-oriented interface
 * @export
 * @class DetectionsApi
 * @extends {BaseAPI}
 */
export class DetectionsApi extends BaseAPI {
    /**
     * API endpoint that allows detections to be viewed or edited.
     * @param {Detection} detection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetectionsApi
     */
    public detectionsCreate(detection: Detection, options?: RawAxiosRequestConfig) {
        return DetectionsApiFp(this.configuration).detectionsCreate(detection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows detections to be viewed or edited.
     * @param {number} id A unique integer value identifying this detection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetectionsApi
     */
    public detectionsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return DetectionsApiFp(this.configuration).detectionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows detections to be viewed or edited.
     * @param {number} [detectionAlgorithm] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {number} [sourceImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetectionsApi
     */
    public detectionsList(detectionAlgorithm?: number, limit?: number, offset?: number, ordering?: string, search?: string, sourceImage?: number, options?: RawAxiosRequestConfig) {
        return DetectionsApiFp(this.configuration).detectionsList(detectionAlgorithm, limit, offset, ordering, search, sourceImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows detections to be viewed or edited.
     * @param {number} id A unique integer value identifying this detection.
     * @param {PatchedDetection} [patchedDetection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetectionsApi
     */
    public detectionsPartialUpdate(id: number, patchedDetection?: PatchedDetection, options?: RawAxiosRequestConfig) {
        return DetectionsApiFp(this.configuration).detectionsPartialUpdate(id, patchedDetection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows detections to be viewed or edited.
     * @param {number} id A unique integer value identifying this detection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetectionsApi
     */
    public detectionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return DetectionsApiFp(this.configuration).detectionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows detections to be viewed or edited.
     * @param {number} id A unique integer value identifying this detection.
     * @param {Detection} detection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DetectionsApi
     */
    public detectionsUpdate(id: number, detection: Detection, options?: RawAxiosRequestConfig) {
        return DetectionsApiFp(this.configuration).detectionsUpdate(id, detection, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate: async (event: Event, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('eventsCreate', 'event', event)
            const localVarPath = `/api/v2/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsDestroy', 'id', id)
            const localVarPath = `/api/v2/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} [deployment] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList: async (deployment?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployment !== undefined) {
                localVarQueryParameter['deployment'] = deployment;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {PatchedEvent} [patchedEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPartialUpdate: async (id: number, patchedEvent?: PatchedEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsRetrieve', 'id', id)
            const localVarPath = `/api/v2/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate: async (id: number, event: Event, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsUpdate', 'id', id)
            // verify required parameter 'event' is not null or undefined
            assertParamExists('eventsUpdate', 'event', event)
            const localVarPath = `/api/v2/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsCreate(event: Event, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsCreate(event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.eventsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.eventsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} [deployment] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsList(deployment?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEventListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsList(deployment, limit, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.eventsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {PatchedEvent} [patchedEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsPartialUpdate(id: number, patchedEvent?: PatchedEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsPartialUpdate(id, patchedEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.eventsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.eventsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsUpdate(id: number, event: Event, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsUpdate(id, event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.eventsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate(event: Event, options?: any): AxiosPromise<Event> {
            return localVarFp.eventsCreate(event, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.eventsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} [deployment] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(deployment?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedEventListList> {
            return localVarFp.eventsList(deployment, limit, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {PatchedEvent} [patchedEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPartialUpdate(id: number, patchedEvent?: PatchedEvent, options?: any): AxiosPromise<Event> {
            return localVarFp.eventsPartialUpdate(id, patchedEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRetrieve(id: number, options?: any): AxiosPromise<Event> {
            return localVarFp.eventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows events to be viewed or edited.
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate(id: number, event: Event, options?: any): AxiosPromise<Event> {
            return localVarFp.eventsUpdate(id, event, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * API endpoint that allows events to be viewed or edited.
     * @param {Event} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsCreate(event: Event, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsCreate(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows events to be viewed or edited.
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows events to be viewed or edited.
     * @param {number} [deployment] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsList(deployment?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsList(deployment, limit, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows events to be viewed or edited.
     * @param {number} id A unique integer value identifying this event.
     * @param {PatchedEvent} [patchedEvent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsPartialUpdate(id: number, patchedEvent?: PatchedEvent, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsPartialUpdate(id, patchedEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows events to be viewed or edited.
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows events to be viewed or edited.
     * @param {number} id A unique integer value identifying this event.
     * @param {Event} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsUpdate(id: number, event: Event, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsUpdate(id, event, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentificationsApi - axios parameter creator
 * @export
 */
export const IdentificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {Identification} identification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsCreate: async (identification: Identification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identification' is not null or undefined
            assertParamExists('identificationsCreate', 'identification', identification)
            const localVarPath = `/api/v2/identifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identificationsDestroy', 'id', id)
            const localVarPath = `/api/v2/identifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [occurrence] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [taxon] 
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsList: async (limit?: number, occurrence?: number, offset?: number, ordering?: string, search?: string, taxon?: number, user?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/identifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (occurrence !== undefined) {
                localVarQueryParameter['occurrence'] = occurrence;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (taxon !== undefined) {
                localVarQueryParameter['taxon'] = taxon;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {PatchedIdentification} [patchedIdentification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsPartialUpdate: async (id: number, patchedIdentification?: PatchedIdentification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identificationsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/identifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIdentification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identificationsRetrieve', 'id', id)
            const localVarPath = `/api/v2/identifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {Identification} identification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsUpdate: async (id: number, identification: Identification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identificationsUpdate', 'id', id)
            // verify required parameter 'identification' is not null or undefined
            assertParamExists('identificationsUpdate', 'identification', identification)
            const localVarPath = `/api/v2/identifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentificationsApi - functional programming interface
 * @export
 */
export const IdentificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {Identification} identification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identificationsCreate(identification: Identification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Identification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identificationsCreate(identification, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationsApi.identificationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identificationsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identificationsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationsApi.identificationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [occurrence] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [taxon] 
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identificationsList(limit?: number, occurrence?: number, offset?: number, ordering?: string, search?: string, taxon?: number, user?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIdentificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identificationsList(limit, occurrence, offset, ordering, search, taxon, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationsApi.identificationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {PatchedIdentification} [patchedIdentification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identificationsPartialUpdate(id: number, patchedIdentification?: PatchedIdentification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Identification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identificationsPartialUpdate(id, patchedIdentification, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationsApi.identificationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identificationsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Identification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identificationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationsApi.identificationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {Identification} identification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identificationsUpdate(id: number, identification: Identification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Identification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identificationsUpdate(id, identification, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationsApi.identificationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentificationsApi - factory interface
 * @export
 */
export const IdentificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentificationsApiFp(configuration)
    return {
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {Identification} identification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsCreate(identification: Identification, options?: any): AxiosPromise<Identification> {
            return localVarFp.identificationsCreate(identification, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.identificationsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [occurrence] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [taxon] 
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsList(limit?: number, occurrence?: number, offset?: number, ordering?: string, search?: string, taxon?: number, user?: number, options?: any): AxiosPromise<PaginatedIdentificationList> {
            return localVarFp.identificationsList(limit, occurrence, offset, ordering, search, taxon, user, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {PatchedIdentification} [patchedIdentification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsPartialUpdate(id: number, patchedIdentification?: PatchedIdentification, options?: any): AxiosPromise<Identification> {
            return localVarFp.identificationsPartialUpdate(id, patchedIdentification, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsRetrieve(id: number, options?: any): AxiosPromise<Identification> {
            return localVarFp.identificationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows identifications to be viewed or edited.
         * @param {number} id A unique integer value identifying this identification.
         * @param {Identification} identification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identificationsUpdate(id: number, identification: Identification, options?: any): AxiosPromise<Identification> {
            return localVarFp.identificationsUpdate(id, identification, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentificationsApi - object-oriented interface
 * @export
 * @class IdentificationsApi
 * @extends {BaseAPI}
 */
export class IdentificationsApi extends BaseAPI {
    /**
     * API endpoint that allows identifications to be viewed or edited.
     * @param {Identification} identification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public identificationsCreate(identification: Identification, options?: RawAxiosRequestConfig) {
        return IdentificationsApiFp(this.configuration).identificationsCreate(identification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows identifications to be viewed or edited.
     * @param {number} id A unique integer value identifying this identification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public identificationsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return IdentificationsApiFp(this.configuration).identificationsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows identifications to be viewed or edited.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [occurrence] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {number} [taxon] 
     * @param {number} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public identificationsList(limit?: number, occurrence?: number, offset?: number, ordering?: string, search?: string, taxon?: number, user?: number, options?: RawAxiosRequestConfig) {
        return IdentificationsApiFp(this.configuration).identificationsList(limit, occurrence, offset, ordering, search, taxon, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows identifications to be viewed or edited.
     * @param {number} id A unique integer value identifying this identification.
     * @param {PatchedIdentification} [patchedIdentification] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public identificationsPartialUpdate(id: number, patchedIdentification?: PatchedIdentification, options?: RawAxiosRequestConfig) {
        return IdentificationsApiFp(this.configuration).identificationsPartialUpdate(id, patchedIdentification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows identifications to be viewed or edited.
     * @param {number} id A unique integer value identifying this identification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public identificationsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return IdentificationsApiFp(this.configuration).identificationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows identifications to be viewed or edited.
     * @param {number} id A unique integer value identifying this identification.
     * @param {Identification} identification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public identificationsUpdate(id: number, identification: Identification, options?: RawAxiosRequestConfig) {
        return IdentificationsApiFp(this.configuration).identificationsUpdate(id, identification, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsCancelCreate: async (id: number, job: Job, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsCancelCreate', 'id', id)
            // verify required parameter 'job' is not null or undefined
            assertParamExists('jobsCancelCreate', 'job', job)
            const localVarPath = `/api/v2/jobs/{id}/cancel/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsCreate: async (job: Job, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'job' is not null or undefined
            assertParamExists('jobsCreate', 'job', job)
            const localVarPath = `/api/v2/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsDestroy', 'id', id)
            const localVarPath = `/api/v2/jobs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} [deployment] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [pipeline] 
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {number} [sourceImageCollection] 
         * @param {JobsListStatusEnum} [status] * &#x60;CREATED&#x60; - CREATED * &#x60;PENDING&#x60; - PENDING * &#x60;STARTED&#x60; - STARTED * &#x60;SUCCESS&#x60; - SUCCESS * &#x60;FAILURE&#x60; - FAILURE * &#x60;RETRY&#x60; - RETRY * &#x60;CANCELING&#x60; - CANCELING * &#x60;REVOKED&#x60; - REVOKED * &#x60;RECEIVED&#x60; - RECEIVED * &#x60;UNKNOWN&#x60; - UNKNOWN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsList: async (deployment?: number, limit?: number, offset?: number, ordering?: string, pipeline?: number, project?: number, search?: string, sourceImageCollection?: number, status?: JobsListStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployment !== undefined) {
                localVarQueryParameter['deployment'] = deployment;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pipeline !== undefined) {
                localVarQueryParameter['pipeline'] = pipeline;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sourceImageCollection !== undefined) {
                localVarQueryParameter['source_image_collection'] = sourceImageCollection;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {PatchedJob} [patchedJob] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsPartialUpdate: async (id: number, patchedJob?: PatchedJob, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/jobs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedJob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsRetrieve', 'id', id)
            const localVarPath = `/api/v2/jobs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a job (add it to the queue).
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsRunCreate: async (id: number, job: Job, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsRunCreate', 'id', id)
            // verify required parameter 'job' is not null or undefined
            assertParamExists('jobsRunCreate', 'job', job)
            const localVarPath = `/api/v2/jobs/{id}/run/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsUpdate: async (id: number, job: Job, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsUpdate', 'id', id)
            // verify required parameter 'job' is not null or undefined
            assertParamExists('jobsUpdate', 'job', job)
            const localVarPath = `/api/v2/jobs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsCancelCreate(id: number, job: Job, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsCancelCreate(id, job, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsCancelCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsCreate(job: Job, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsCreate(job, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} [deployment] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [pipeline] 
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {number} [sourceImageCollection] 
         * @param {JobsListStatusEnum} [status] * &#x60;CREATED&#x60; - CREATED * &#x60;PENDING&#x60; - PENDING * &#x60;STARTED&#x60; - STARTED * &#x60;SUCCESS&#x60; - SUCCESS * &#x60;FAILURE&#x60; - FAILURE * &#x60;RETRY&#x60; - RETRY * &#x60;CANCELING&#x60; - CANCELING * &#x60;REVOKED&#x60; - REVOKED * &#x60;RECEIVED&#x60; - RECEIVED * &#x60;UNKNOWN&#x60; - UNKNOWN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsList(deployment?: number, limit?: number, offset?: number, ordering?: string, pipeline?: number, project?: number, search?: string, sourceImageCollection?: number, status?: JobsListStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJobListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsList(deployment, limit, offset, ordering, pipeline, project, search, sourceImageCollection, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {PatchedJob} [patchedJob] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsPartialUpdate(id: number, patchedJob?: PatchedJob, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsPartialUpdate(id, patchedJob, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a job (add it to the queue).
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsRunCreate(id: number, job: Job, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsRunCreate(id, job, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsRunCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsUpdate(id: number, job: Job, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsUpdate(id, job, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsCancelCreate(id: number, job: Job, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsCancelCreate(id, job, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsCreate(job: Job, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsCreate(job, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.jobsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} [deployment] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [pipeline] 
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {number} [sourceImageCollection] 
         * @param {JobsListStatusEnum} [status] * &#x60;CREATED&#x60; - CREATED * &#x60;PENDING&#x60; - PENDING * &#x60;STARTED&#x60; - STARTED * &#x60;SUCCESS&#x60; - SUCCESS * &#x60;FAILURE&#x60; - FAILURE * &#x60;RETRY&#x60; - RETRY * &#x60;CANCELING&#x60; - CANCELING * &#x60;REVOKED&#x60; - REVOKED * &#x60;RECEIVED&#x60; - RECEIVED * &#x60;UNKNOWN&#x60; - UNKNOWN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsList(deployment?: number, limit?: number, offset?: number, ordering?: string, pipeline?: number, project?: number, search?: string, sourceImageCollection?: number, status?: JobsListStatusEnum, options?: any): AxiosPromise<PaginatedJobListList> {
            return localVarFp.jobsList(deployment, limit, offset, ordering, pipeline, project, search, sourceImageCollection, status, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {PatchedJob} [patchedJob] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsPartialUpdate(id: number, patchedJob?: PatchedJob, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsPartialUpdate(id, patchedJob, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsRetrieve(id: number, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a job (add it to the queue).
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsRunCreate(id: number, job: Job, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsRunCreate(id, job, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
         * @param {number} id A unique integer value identifying this job.
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsUpdate(id: number, job: Job, options?: any): AxiosPromise<Job> {
            return localVarFp.jobsUpdate(id, job, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Cancel a job (terminate the background task)
     * @param {number} id A unique integer value identifying this job.
     * @param {Job} job 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsCancelCreate(id: number, job: Job, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsCancelCreate(id, job, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
     * @param {Job} job 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsCreate(job: Job, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsCreate(job, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
     * @param {number} id A unique integer value identifying this job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
     * @param {number} [deployment] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [pipeline] 
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {number} [sourceImageCollection] 
     * @param {JobsListStatusEnum} [status] * &#x60;CREATED&#x60; - CREATED * &#x60;PENDING&#x60; - PENDING * &#x60;STARTED&#x60; - STARTED * &#x60;SUCCESS&#x60; - SUCCESS * &#x60;FAILURE&#x60; - FAILURE * &#x60;RETRY&#x60; - RETRY * &#x60;CANCELING&#x60; - CANCELING * &#x60;REVOKED&#x60; - REVOKED * &#x60;RECEIVED&#x60; - RECEIVED * &#x60;UNKNOWN&#x60; - UNKNOWN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsList(deployment?: number, limit?: number, offset?: number, ordering?: string, pipeline?: number, project?: number, search?: string, sourceImageCollection?: number, status?: JobsListStatusEnum, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsList(deployment, limit, offset, ordering, pipeline, project, search, sourceImageCollection, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
     * @param {number} id A unique integer value identifying this job.
     * @param {PatchedJob} [patchedJob] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsPartialUpdate(id: number, patchedJob?: PatchedJob, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsPartialUpdate(id, patchedJob, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
     * @param {number} id A unique integer value identifying this job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a job (add it to the queue).
     * @param {number} id A unique integer value identifying this job.
     * @param {Job} job 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsRunCreate(id: number, job: Job, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsRunCreate(id, job, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows jobs to be viewed or edited.  Pass the ``start_now`` url parameter to the ``POST`` method to enqueue the job immediately.  Use the `delay` field to create a test job with fake duration of work (in seconds).  ## Actions  ### `/jobs/{id}/run/` (`POST`)  Run a job (add it to the queue).  ### `/jobs/{id}/cancel/` (`POST`)  Cancel a job (terminate the background task)
     * @param {number} id A unique integer value identifying this job.
     * @param {Job} job 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsUpdate(id: number, job: Job, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsUpdate(id, job, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const JobsListStatusEnum = {
    Canceling: 'CANCELING',
    Created: 'CREATED',
    Failure: 'FAILURE',
    Pending: 'PENDING',
    Received: 'RECEIVED',
    Retry: 'RETRY',
    Revoked: 'REVOKED',
    Started: 'STARTED',
    Success: 'SUCCESS',
    Unknown: 'UNKNOWN'
} as const;
export type JobsListStatusEnum = typeof JobsListStatusEnum[keyof typeof JobsListStatusEnum];


/**
 * LabelstudioApi - axios parameter creator
 * @export
 */
export const LabelstudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a sample of captures based on time intervals. URL parameters: - `deployment`: limit to a specific deployment<br> - `project`: limit to all deployments in a specific project<br> - `event_day_interval`: number of days between events<br> - `capture_minute_interval`: number of minutes between captures<br> - `limit`: maximum number of captures to return<br> Example: `/api/labelstudio/captures/interval/?project=1&event_day_interval=3&capture_minute_interval=30&limit=100`  # noqa Objects are returned in a format ready to import as a list of Label Studio tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioCapturesIntervalRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/captures/interval/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for importing data to annotate in Label Studio.
         * @param {number} [deployment] 
         * @param {number} [deploymentProject] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioCapturesList: async (deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/captures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployment !== undefined) {
                localVarQueryParameter['deployment'] = deployment;
            }

            if (deploymentProject !== undefined) {
                localVarQueryParameter['deployment__project'] = deploymentProject;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for importing data to annotate in Label Studio.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioCapturesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('labelstudioCapturesRetrieve', 'id', id)
            const localVarPath = `/api/v2/labelstudio/captures/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigAllInOneRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/config/all_in_one/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigBinaryclassificationRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/config/binaryclassification/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigObjectdetectionRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/config/objectdetection/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigSpeciesclassificationRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/config/speciesclassification/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide the species choices via an API endpoint.  https://labelstud.io/tags/taxonomy.html  Label studio may pass an array of path[] params to specify which children to return. For example: /taxonomy?path[]=root&path[]=child1 to return only nested children of child1  Because names are unique, we will only consider the last path[] param and return all children of that node.  It is required to return the display name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigTaxonomyRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/config/taxonomy/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [sourceImageDeployment] 
         * @param {number} [sourceImageDeploymentProject] 
         * @param {number} [sourceImageEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioDetectionsList: async (limit?: number, offset?: number, ordering?: string, search?: string, sourceImageDeployment?: number, sourceImageDeploymentProject?: number, sourceImageEvent?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/detections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sourceImageDeployment !== undefined) {
                localVarQueryParameter['source_image__deployment'] = sourceImageDeployment;
            }

            if (sourceImageDeploymentProject !== undefined) {
                localVarQueryParameter['source_image__deployment__project'] = sourceImageDeploymentProject;
            }

            if (sourceImageEvent !== undefined) {
                localVarQueryParameter['source_image__event'] = sourceImageEvent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioDetectionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('labelstudioDetectionsRetrieve', 'id', id)
            const localVarPath = `/api/v2/labelstudio/detections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoints for Label Studio to send data to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioHooksAllCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/hooks/all/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [deployment] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioOccurrencesList: async (deployment?: number, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/labelstudio/occurrences/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployment !== undefined) {
                localVarQueryParameter['deployment'] = deployment;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioOccurrencesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('labelstudioOccurrencesRetrieve', 'id', id)
            const localVarPath = `/api/v2/labelstudio/occurrences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabelstudioApi - functional programming interface
 * @export
 */
export const LabelstudioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LabelstudioApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a sample of captures based on time intervals. URL parameters: - `deployment`: limit to a specific deployment<br> - `project`: limit to all deployments in a specific project<br> - `event_day_interval`: number of days between events<br> - `capture_minute_interval`: number of minutes between captures<br> - `limit`: maximum number of captures to return<br> Example: `/api/labelstudio/captures/interval/?project=1&event_day_interval=3&capture_minute_interval=30&limit=100`  # noqa Objects are returned in a format ready to import as a list of Label Studio tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioCapturesIntervalRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelStudioSourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioCapturesIntervalRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioCapturesIntervalRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for importing data to annotate in Label Studio.
         * @param {number} [deployment] 
         * @param {number} [deploymentProject] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioCapturesList(deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLabelStudioSourceImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioCapturesList(deployment, deploymentProject, event, limit, offset, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioCapturesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for importing data to annotate in Label Studio.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioCapturesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelStudioSourceImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioCapturesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioCapturesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioConfigAllInOneRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioConfigAllInOneRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioConfigAllInOneRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioConfigBinaryclassificationRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioConfigBinaryclassificationRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioConfigBinaryclassificationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioConfigObjectdetectionRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioConfigObjectdetectionRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioConfigObjectdetectionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioConfigSpeciesclassificationRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioConfigSpeciesclassificationRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioConfigSpeciesclassificationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Provide the species choices via an API endpoint.  https://labelstud.io/tags/taxonomy.html  Label studio may pass an array of path[] params to specify which children to return. For example: /taxonomy?path[]=root&path[]=child1 to return only nested children of child1  Because names are unique, we will only consider the last path[] param and return all children of that node.  It is required to return the display name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioConfigTaxonomyRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioConfigTaxonomyRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioConfigTaxonomyRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [sourceImageDeployment] 
         * @param {number} [sourceImageDeploymentProject] 
         * @param {number} [sourceImageEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioDetectionsList(limit?: number, offset?: number, ordering?: string, search?: string, sourceImageDeployment?: number, sourceImageDeploymentProject?: number, sourceImageEvent?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLabelStudioDetectionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioDetectionsList(limit, offset, ordering, search, sourceImageDeployment, sourceImageDeploymentProject, sourceImageEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioDetectionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioDetectionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelStudioDetection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioDetectionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioDetectionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoints for Label Studio to send data to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioHooksAllCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioHooksAllCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioHooksAllCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [deployment] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioOccurrencesList(deployment?: number, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLabelStudioOccurrenceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioOccurrencesList(deployment, event, limit, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioOccurrencesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelstudioOccurrencesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelStudioOccurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labelstudioOccurrencesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LabelstudioApi.labelstudioOccurrencesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LabelstudioApi - factory interface
 * @export
 */
export const LabelstudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LabelstudioApiFp(configuration)
    return {
        /**
         * Return a sample of captures based on time intervals. URL parameters: - `deployment`: limit to a specific deployment<br> - `project`: limit to all deployments in a specific project<br> - `event_day_interval`: number of days between events<br> - `capture_minute_interval`: number of minutes between captures<br> - `limit`: maximum number of captures to return<br> Example: `/api/labelstudio/captures/interval/?project=1&event_day_interval=3&capture_minute_interval=30&limit=100`  # noqa Objects are returned in a format ready to import as a list of Label Studio tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioCapturesIntervalRetrieve(options?: any): AxiosPromise<LabelStudioSourceImage> {
            return localVarFp.labelstudioCapturesIntervalRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for importing data to annotate in Label Studio.
         * @param {number} [deployment] 
         * @param {number} [deploymentProject] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioCapturesList(deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options?: any): AxiosPromise<PaginatedLabelStudioSourceImageList> {
            return localVarFp.labelstudioCapturesList(deployment, deploymentProject, event, limit, offset, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for importing data to annotate in Label Studio.
         * @param {number} id A unique integer value identifying this source image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioCapturesRetrieve(id: number, options?: any): AxiosPromise<LabelStudioSourceImage> {
            return localVarFp.labelstudioCapturesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigAllInOneRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.labelstudioConfigAllInOneRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigBinaryclassificationRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.labelstudioConfigBinaryclassificationRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigObjectdetectionRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.labelstudioConfigObjectdetectionRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigSpeciesclassificationRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.labelstudioConfigSpeciesclassificationRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Provide the species choices via an API endpoint.  https://labelstud.io/tags/taxonomy.html  Label studio may pass an array of path[] params to specify which children to return. For example: /taxonomy?path[]=root&path[]=child1 to return only nested children of child1  Because names are unique, we will only consider the last path[] param and return all children of that node.  It is required to return the display name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioConfigTaxonomyRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.labelstudioConfigTaxonomyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [sourceImageDeployment] 
         * @param {number} [sourceImageDeploymentProject] 
         * @param {number} [sourceImageEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioDetectionsList(limit?: number, offset?: number, ordering?: string, search?: string, sourceImageDeployment?: number, sourceImageDeploymentProject?: number, sourceImageEvent?: number, options?: any): AxiosPromise<PaginatedLabelStudioDetectionList> {
            return localVarFp.labelstudioDetectionsList(limit, offset, ordering, search, sourceImageDeployment, sourceImageDeploymentProject, sourceImageEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this detection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioDetectionsRetrieve(id: number, options?: any): AxiosPromise<LabelStudioDetection> {
            return localVarFp.labelstudioDetectionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoints for Label Studio to send data to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioHooksAllCreate(options?: any): AxiosPromise<void> {
            return localVarFp.labelstudioHooksAllCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [deployment] 
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioOccurrencesList(deployment?: number, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedLabelStudioOccurrenceList> {
            return localVarFp.labelstudioOccurrencesList(deployment, event, limit, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelstudioOccurrencesRetrieve(id: number, options?: any): AxiosPromise<LabelStudioOccurrence> {
            return localVarFp.labelstudioOccurrencesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LabelstudioApi - object-oriented interface
 * @export
 * @class LabelstudioApi
 * @extends {BaseAPI}
 */
export class LabelstudioApi extends BaseAPI {
    /**
     * Return a sample of captures based on time intervals. URL parameters: - `deployment`: limit to a specific deployment<br> - `project`: limit to all deployments in a specific project<br> - `event_day_interval`: number of days between events<br> - `capture_minute_interval`: number of minutes between captures<br> - `limit`: maximum number of captures to return<br> Example: `/api/labelstudio/captures/interval/?project=1&event_day_interval=3&capture_minute_interval=30&limit=100`  # noqa Objects are returned in a format ready to import as a list of Label Studio tasks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioCapturesIntervalRetrieve(options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioCapturesIntervalRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for importing data to annotate in Label Studio.
     * @param {number} [deployment] 
     * @param {number} [deploymentProject] 
     * @param {number} [event] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioCapturesList(deployment?: number, deploymentProject?: number, event?: number, limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioCapturesList(deployment, deploymentProject, event, limit, offset, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for importing data to annotate in Label Studio.
     * @param {number} id A unique integer value identifying this source image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioCapturesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioCapturesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioConfigAllInOneRetrieve(options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioConfigAllInOneRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioConfigBinaryclassificationRetrieve(options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioConfigBinaryclassificationRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioConfigObjectdetectionRetrieve(options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioConfigObjectdetectionRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioConfigSpeciesclassificationRetrieve(options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioConfigSpeciesclassificationRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide the species choices via an API endpoint.  https://labelstud.io/tags/taxonomy.html  Label studio may pass an array of path[] params to specify which children to return. For example: /taxonomy?path[]=root&path[]=child1 to return only nested children of child1  Because names are unique, we will only consider the last path[] param and return all children of that node.  It is required to return the display name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioConfigTaxonomyRetrieve(options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioConfigTaxonomyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {number} [sourceImageDeployment] 
     * @param {number} [sourceImageDeploymentProject] 
     * @param {number} [sourceImageEvent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioDetectionsList(limit?: number, offset?: number, ordering?: string, search?: string, sourceImageDeployment?: number, sourceImageDeploymentProject?: number, sourceImageEvent?: number, options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioDetectionsList(limit, offset, ordering, search, sourceImageDeployment, sourceImageDeploymentProject, sourceImageEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this detection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioDetectionsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioDetectionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoints for Label Studio to send data to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioHooksAllCreate(options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioHooksAllCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [deployment] 
     * @param {number} [event] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioOccurrencesList(deployment?: number, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioOccurrencesList(deployment, event, limit, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this occurrence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelstudioApi
     */
    public labelstudioOccurrencesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return LabelstudioApiFp(this.configuration).labelstudioOccurrencesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MlApi - axios parameter creator
 * @export
 */
export const MlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {Algorithm} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsCreate: async (algorithm: Algorithm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('mlAlgorithmsCreate', 'algorithm', algorithm)
            const localVarPath = `/api/v2/ml/algorithms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(algorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlAlgorithmsDestroy', 'id', id)
            const localVarPath = `/api/v2/ml/algorithms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsList: async (limit?: number, name?: string, offset?: number, ordering?: string, search?: string, version?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/ml/algorithms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {PatchedAlgorithm} [patchedAlgorithm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsPartialUpdate: async (id: number, patchedAlgorithm?: PatchedAlgorithm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlAlgorithmsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/ml/algorithms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlAlgorithmsRetrieve', 'id', id)
            const localVarPath = `/api/v2/ml/algorithms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {Algorithm} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsUpdate: async (id: number, algorithm: Algorithm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlAlgorithmsUpdate', 'id', id)
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('mlAlgorithmsUpdate', 'algorithm', algorithm)
            const localVarPath = `/api/v2/ml/algorithms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(algorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesCreate: async (pipeline: Pipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('mlPipelinesCreate', 'pipeline', pipeline)
            const localVarPath = `/api/v2/ml/pipelines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlPipelinesDestroy', 'id', id)
            const localVarPath = `/api/v2/ml/pipelines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesList: async (limit?: number, offset?: number, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/ml/pipelines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {PatchedPipeline} [patchedPipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesPartialUpdate: async (id: number, patchedPipeline?: PatchedPipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlPipelinesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/ml/pipelines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlPipelinesRetrieve', 'id', id)
            const localVarPath = `/api/v2/ml/pipelines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesUpdate: async (id: number, pipeline: Pipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mlPipelinesUpdate', 'id', id)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('mlPipelinesUpdate', 'pipeline', pipeline)
            const localVarPath = `/api/v2/ml/pipelines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MlApi - functional programming interface
 * @export
 */
export const MlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MlApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {Algorithm} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlAlgorithmsCreate(algorithm: Algorithm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Algorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlAlgorithmsCreate(algorithm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlAlgorithmsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlAlgorithmsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlAlgorithmsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlAlgorithmsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlAlgorithmsList(limit?: number, name?: string, offset?: number, ordering?: string, search?: string, version?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAlgorithmList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlAlgorithmsList(limit, name, offset, ordering, search, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlAlgorithmsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {PatchedAlgorithm} [patchedAlgorithm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlAlgorithmsPartialUpdate(id: number, patchedAlgorithm?: PatchedAlgorithm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Algorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlAlgorithmsPartialUpdate(id, patchedAlgorithm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlAlgorithmsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlAlgorithmsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Algorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlAlgorithmsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlAlgorithmsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {Algorithm} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlAlgorithmsUpdate(id: number, algorithm: Algorithm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Algorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlAlgorithmsUpdate(id, algorithm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlAlgorithmsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlPipelinesCreate(pipeline: Pipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlPipelinesCreate(pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlPipelinesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlPipelinesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlPipelinesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlPipelinesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlPipelinesList(limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPipelineList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlPipelinesList(limit, offset, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlPipelinesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {PatchedPipeline} [patchedPipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlPipelinesPartialUpdate(id: number, patchedPipeline?: PatchedPipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlPipelinesPartialUpdate(id, patchedPipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlPipelinesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlPipelinesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlPipelinesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlPipelinesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mlPipelinesUpdate(id: number, pipeline: Pipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mlPipelinesUpdate(id, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MlApi.mlPipelinesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MlApi - factory interface
 * @export
 */
export const MlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MlApiFp(configuration)
    return {
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {Algorithm} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsCreate(algorithm: Algorithm, options?: any): AxiosPromise<Algorithm> {
            return localVarFp.mlAlgorithmsCreate(algorithm, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.mlAlgorithmsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {number} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsList(limit?: number, name?: string, offset?: number, ordering?: string, search?: string, version?: number, options?: any): AxiosPromise<PaginatedAlgorithmList> {
            return localVarFp.mlAlgorithmsList(limit, name, offset, ordering, search, version, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {PatchedAlgorithm} [patchedAlgorithm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsPartialUpdate(id: number, patchedAlgorithm?: PatchedAlgorithm, options?: any): AxiosPromise<Algorithm> {
            return localVarFp.mlAlgorithmsPartialUpdate(id, patchedAlgorithm, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsRetrieve(id: number, options?: any): AxiosPromise<Algorithm> {
            return localVarFp.mlAlgorithmsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows algorithm (ML models) to be viewed or edited.
         * @param {number} id A unique integer value identifying this algorithm.
         * @param {Algorithm} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlAlgorithmsUpdate(id: number, algorithm: Algorithm, options?: any): AxiosPromise<Algorithm> {
            return localVarFp.mlAlgorithmsUpdate(id, algorithm, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesCreate(pipeline: Pipeline, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.mlPipelinesCreate(pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.mlPipelinesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesList(limit?: number, offset?: number, ordering?: string, search?: string, options?: any): AxiosPromise<PaginatedPipelineList> {
            return localVarFp.mlPipelinesList(limit, offset, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {PatchedPipeline} [patchedPipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesPartialUpdate(id: number, patchedPipeline?: PatchedPipeline, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.mlPipelinesPartialUpdate(id, patchedPipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesRetrieve(id: number, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.mlPipelinesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pipelines to be viewed or edited.
         * @param {number} id A unique integer value identifying this pipeline.
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mlPipelinesUpdate(id: number, pipeline: Pipeline, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.mlPipelinesUpdate(id, pipeline, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MlApi - object-oriented interface
 * @export
 * @class MlApi
 * @extends {BaseAPI}
 */
export class MlApi extends BaseAPI {
    /**
     * API endpoint that allows algorithm (ML models) to be viewed or edited.
     * @param {Algorithm} algorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlAlgorithmsCreate(algorithm: Algorithm, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlAlgorithmsCreate(algorithm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows algorithm (ML models) to be viewed or edited.
     * @param {number} id A unique integer value identifying this algorithm.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlAlgorithmsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlAlgorithmsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows algorithm (ML models) to be viewed or edited.
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {number} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlAlgorithmsList(limit?: number, name?: string, offset?: number, ordering?: string, search?: string, version?: number, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlAlgorithmsList(limit, name, offset, ordering, search, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows algorithm (ML models) to be viewed or edited.
     * @param {number} id A unique integer value identifying this algorithm.
     * @param {PatchedAlgorithm} [patchedAlgorithm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlAlgorithmsPartialUpdate(id: number, patchedAlgorithm?: PatchedAlgorithm, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlAlgorithmsPartialUpdate(id, patchedAlgorithm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows algorithm (ML models) to be viewed or edited.
     * @param {number} id A unique integer value identifying this algorithm.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlAlgorithmsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlAlgorithmsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows algorithm (ML models) to be viewed or edited.
     * @param {number} id A unique integer value identifying this algorithm.
     * @param {Algorithm} algorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlAlgorithmsUpdate(id: number, algorithm: Algorithm, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlAlgorithmsUpdate(id, algorithm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pipelines to be viewed or edited.
     * @param {Pipeline} pipeline 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlPipelinesCreate(pipeline: Pipeline, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlPipelinesCreate(pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pipelines to be viewed or edited.
     * @param {number} id A unique integer value identifying this pipeline.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlPipelinesDestroy(id: number, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlPipelinesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pipelines to be viewed or edited.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlPipelinesList(limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlPipelinesList(limit, offset, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pipelines to be viewed or edited.
     * @param {number} id A unique integer value identifying this pipeline.
     * @param {PatchedPipeline} [patchedPipeline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlPipelinesPartialUpdate(id: number, patchedPipeline?: PatchedPipeline, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlPipelinesPartialUpdate(id, patchedPipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pipelines to be viewed or edited.
     * @param {number} id A unique integer value identifying this pipeline.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlPipelinesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlPipelinesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pipelines to be viewed or edited.
     * @param {number} id A unique integer value identifying this pipeline.
     * @param {Pipeline} pipeline 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlApi
     */
    public mlPipelinesUpdate(id: number, pipeline: Pipeline, options?: RawAxiosRequestConfig) {
        return MlApiFp(this.configuration).mlPipelinesUpdate(id, pipeline, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OccurrencesApi - axios parameter creator
 * @export
 */
export const OccurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {Occurrence} [occurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesCreate: async (occurrence?: Occurrence, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/occurrences/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(occurrence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('occurrencesDestroy', 'id', id)
            const localVarPath = `/api/v2/occurrences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} [deployment] 
         * @param {number} [determination] 
         * @param {OccurrencesListDeterminationRankEnum} [determinationRank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesList: async (deployment?: number, determination?: number, determinationRank?: OccurrencesListDeterminationRankEnum, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/occurrences/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployment !== undefined) {
                localVarQueryParameter['deployment'] = deployment;
            }

            if (determination !== undefined) {
                localVarQueryParameter['determination'] = determination;
            }

            if (determinationRank !== undefined) {
                localVarQueryParameter['determination__rank'] = determinationRank;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {PatchedOccurrence} [patchedOccurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesPartialUpdate: async (id: number, patchedOccurrence?: PatchedOccurrence, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('occurrencesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/occurrences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOccurrence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('occurrencesRetrieve', 'id', id)
            const localVarPath = `/api/v2/occurrences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {Occurrence} [occurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesUpdate: async (id: number, occurrence?: Occurrence, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('occurrencesUpdate', 'id', id)
            const localVarPath = `/api/v2/occurrences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(occurrence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OccurrencesApi - functional programming interface
 * @export
 */
export const OccurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OccurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {Occurrence} [occurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesCreate(occurrence?: Occurrence, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Occurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesCreate(occurrence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.occurrencesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.occurrencesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} [deployment] 
         * @param {number} [determination] 
         * @param {OccurrencesListDeterminationRankEnum} [determinationRank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesList(deployment?: number, determination?: number, determinationRank?: OccurrencesListDeterminationRankEnum, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOccurrenceListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesList(deployment, determination, determinationRank, event, limit, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.occurrencesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {PatchedOccurrence} [patchedOccurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesPartialUpdate(id: number, patchedOccurrence?: PatchedOccurrence, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Occurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesPartialUpdate(id, patchedOccurrence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.occurrencesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Occurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.occurrencesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {Occurrence} [occurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesUpdate(id: number, occurrence?: Occurrence, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Occurrence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesUpdate(id, occurrence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OccurrencesApi.occurrencesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OccurrencesApi - factory interface
 * @export
 */
export const OccurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OccurrencesApiFp(configuration)
    return {
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {Occurrence} [occurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesCreate(occurrence?: Occurrence, options?: any): AxiosPromise<Occurrence> {
            return localVarFp.occurrencesCreate(occurrence, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.occurrencesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} [deployment] 
         * @param {number} [determination] 
         * @param {OccurrencesListDeterminationRankEnum} [determinationRank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
         * @param {number} [event] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesList(deployment?: number, determination?: number, determinationRank?: OccurrencesListDeterminationRankEnum, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedOccurrenceListList> {
            return localVarFp.occurrencesList(deployment, determination, determinationRank, event, limit, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {PatchedOccurrence} [patchedOccurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesPartialUpdate(id: number, patchedOccurrence?: PatchedOccurrence, options?: any): AxiosPromise<Occurrence> {
            return localVarFp.occurrencesPartialUpdate(id, patchedOccurrence, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesRetrieve(id: number, options?: any): AxiosPromise<Occurrence> {
            return localVarFp.occurrencesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows occurrences to be viewed or edited.
         * @param {number} id A unique integer value identifying this occurrence.
         * @param {Occurrence} [occurrence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesUpdate(id: number, occurrence?: Occurrence, options?: any): AxiosPromise<Occurrence> {
            return localVarFp.occurrencesUpdate(id, occurrence, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OccurrencesApi - object-oriented interface
 * @export
 * @class OccurrencesApi
 * @extends {BaseAPI}
 */
export class OccurrencesApi extends BaseAPI {
    /**
     * API endpoint that allows occurrences to be viewed or edited.
     * @param {Occurrence} [occurrence] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesCreate(occurrence?: Occurrence, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesCreate(occurrence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows occurrences to be viewed or edited.
     * @param {number} id A unique integer value identifying this occurrence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesDestroy(id: number, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows occurrences to be viewed or edited.
     * @param {number} [deployment] 
     * @param {number} [determination] 
     * @param {OccurrencesListDeterminationRankEnum} [determinationRank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
     * @param {number} [event] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesList(deployment?: number, determination?: number, determinationRank?: OccurrencesListDeterminationRankEnum, event?: number, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesList(deployment, determination, determinationRank, event, limit, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows occurrences to be viewed or edited.
     * @param {number} id A unique integer value identifying this occurrence.
     * @param {PatchedOccurrence} [patchedOccurrence] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesPartialUpdate(id: number, patchedOccurrence?: PatchedOccurrence, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesPartialUpdate(id, patchedOccurrence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows occurrences to be viewed or edited.
     * @param {number} id A unique integer value identifying this occurrence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows occurrences to be viewed or edited.
     * @param {number} id A unique integer value identifying this occurrence.
     * @param {Occurrence} [occurrence] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesUpdate(id: number, occurrence?: Occurrence, options?: RawAxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesUpdate(id, occurrence, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OccurrencesListDeterminationRankEnum = {
    Family: 'FAMILY',
    Genus: 'GENUS',
    Order: 'ORDER',
    Species: 'SPECIES',
    Subfamily: 'SUBFAMILY',
    Subtribe: 'SUBTRIBE',
    Superfamily: 'SUPERFAMILY',
    Tribe: 'TRIBE',
    Unknown: 'UNKNOWN'
} as const;
export type OccurrencesListDeterminationRankEnum = typeof OccurrencesListDeterminationRankEnum[keyof typeof OccurrencesListDeterminationRankEnum];


/**
 * PagesApi - axios parameter creator
 * @export
 */
export const PagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesCreate: async (page: Page, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('pagesCreate', 'page', page)
            const localVarPath = `/api/v2/pages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(page, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDestroy: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('pagesDestroy', 'slug', slug)
            const localVarPath = `/api/v2/pages/{slug}/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [linkClass] 
         * @param {number} [navLevel] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {boolean} [published] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesList: async (limit?: number, linkClass?: string, navLevel?: number, offset?: number, ordering?: string, project?: number, published?: boolean, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/pages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkClass !== undefined) {
                localVarQueryParameter['link_class'] = linkClass;
            }

            if (navLevel !== undefined) {
                localVarQueryParameter['nav_level'] = navLevel;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {PatchedPage} [patchedPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesPartialUpdate: async (slug: string, patchedPage?: PatchedPage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('pagesPartialUpdate', 'slug', slug)
            const localVarPath = `/api/v2/pages/{slug}/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesRetrieve: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('pagesRetrieve', 'slug', slug)
            const localVarPath = `/api/v2/pages/{slug}/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesUpdate: async (slug: string, page: Page, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('pagesUpdate', 'slug', slug)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('pagesUpdate', 'page', page)
            const localVarPath = `/api/v2/pages/{slug}/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(page, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PagesApi - functional programming interface
 * @export
 */
export const PagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PagesApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesCreate(page: Page, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesCreate(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDestroy(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesDestroy(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [linkClass] 
         * @param {number} [navLevel] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {boolean} [published] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesList(limit?: number, linkClass?: string, navLevel?: number, offset?: number, ordering?: string, project?: number, published?: boolean, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPageListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesList(limit, linkClass, navLevel, offset, ordering, project, published, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {PatchedPage} [patchedPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesPartialUpdate(slug: string, patchedPage?: PatchedPage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesPartialUpdate(slug, patchedPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesRetrieve(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesRetrieve(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesUpdate(slug: string, page: Page, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagesUpdate(slug, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PagesApi - factory interface
 * @export
 */
export const PagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PagesApiFp(configuration)
    return {
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesCreate(page: Page, options?: any): AxiosPromise<Page> {
            return localVarFp.pagesCreate(page, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDestroy(slug: string, options?: any): AxiosPromise<void> {
            return localVarFp.pagesDestroy(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [linkClass] 
         * @param {number} [navLevel] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {boolean} [published] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesList(limit?: number, linkClass?: string, navLevel?: number, offset?: number, ordering?: string, project?: number, published?: boolean, search?: string, options?: any): AxiosPromise<PaginatedPageListList> {
            return localVarFp.pagesList(limit, linkClass, navLevel, offset, ordering, project, published, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {PatchedPage} [patchedPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesPartialUpdate(slug: string, patchedPage?: PatchedPage, options?: any): AxiosPromise<Page> {
            return localVarFp.pagesPartialUpdate(slug, patchedPage, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesRetrieve(slug: string, options?: any): AxiosPromise<Page> {
            return localVarFp.pagesRetrieve(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows pages to be viewed or edited.
         * @param {string} slug 
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesUpdate(slug: string, page: Page, options?: any): AxiosPromise<Page> {
            return localVarFp.pagesUpdate(slug, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PagesApi - object-oriented interface
 * @export
 * @class PagesApi
 * @extends {BaseAPI}
 */
export class PagesApi extends BaseAPI {
    /**
     * API endpoint that allows pages to be viewed or edited.
     * @param {Page} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesCreate(page: Page, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesCreate(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pages to be viewed or edited.
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesDestroy(slug: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesDestroy(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pages to be viewed or edited.
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [linkClass] 
     * @param {number} [navLevel] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {boolean} [published] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesList(limit?: number, linkClass?: string, navLevel?: number, offset?: number, ordering?: string, project?: number, published?: boolean, search?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesList(limit, linkClass, navLevel, offset, ordering, project, published, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pages to be viewed or edited.
     * @param {string} slug 
     * @param {PatchedPage} [patchedPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesPartialUpdate(slug: string, patchedPage?: PatchedPage, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesPartialUpdate(slug, patchedPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pages to be viewed or edited.
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesRetrieve(slug: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesRetrieve(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows pages to be viewed or edited.
     * @param {string} slug 
     * @param {Page} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagesUpdate(slug: string, page: Page, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagesUpdate(slug, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (project: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectsCreate', 'project', project)
            const localVarPath = `/api/v2/projects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsDestroy', 'id', id)
            const localVarPath = `/api/v2/projects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList: async (limit?: number, offset?: number, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/projects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {PatchedProject} [patchedProject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPartialUpdate: async (id: number, patchedProject?: PatchedProject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/projects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsRetrieve', 'id', id)
            const localVarPath = `/api/v2/projects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (id: number, project: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsUpdate', 'id', id)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectsUpdate', 'project', project)
            const localVarPath = `/api/v2/projects/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(project: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsList(limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProjectListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsList(limit, offset, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {PatchedProject} [patchedProject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsPartialUpdate(id: number, patchedProject?: PatchedProject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsPartialUpdate(id, patchedProject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(id: number, project: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(id, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(project: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsCreate(project, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.projectsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsList(limit?: number, offset?: number, ordering?: string, search?: string, options?: any): AxiosPromise<PaginatedProjectListList> {
            return localVarFp.projectsList(limit, offset, ordering, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {PatchedProject} [patchedProject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPartialUpdate(id: number, patchedProject?: PatchedProject, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsPartialUpdate(id, patchedProject, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRetrieve(id: number, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows projects to be viewed or edited.
         * @param {number} id A unique integer value identifying this project.
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(id: number, project: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsUpdate(id, project, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * API endpoint that allows projects to be viewed or edited.
     * @param {Project} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsCreate(project: Project, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsCreate(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows projects to be viewed or edited.
     * @param {number} id A unique integer value identifying this project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows projects to be viewed or edited.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsList(limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsList(limit, offset, ordering, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows projects to be viewed or edited.
     * @param {number} id A unique integer value identifying this project.
     * @param {PatchedProject} [patchedProject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsPartialUpdate(id: number, patchedProject?: PatchedProject, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsPartialUpdate(id, patchedProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows projects to be viewed or edited.
     * @param {number} id A unique integer value identifying this project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows projects to be viewed or edited.
     * @param {number} id A unique integer value identifying this project.
     * @param {Project} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsUpdate(id: number, project: Project, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsUpdate(id, project, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * @TODO not totally sure how to use the serializer here yet.
         * @param {StorageStatus} storageStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStorageCreate: async (storageStatus: StorageStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageStatus' is not null or undefined
            assertParamExists('statusStorageCreate', 'storageStatus', storageStatus)
            const localVarPath = `/api/v2/status/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return counts of all models.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSummaryRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/status/summary/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * @TODO not totally sure how to use the serializer here yet.
         * @param {StorageStatus} storageStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusStorageCreate(storageStatus: StorageStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusStorageCreate(storageStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusStorageCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return counts of all models.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusSummaryRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusSummaryRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusSummaryRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * @TODO not totally sure how to use the serializer here yet.
         * @param {StorageStatus} storageStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusStorageCreate(storageStatus: StorageStatus, options?: any): AxiosPromise<StorageStatus> {
            return localVarFp.statusStorageCreate(storageStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Return counts of all models.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusSummaryRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.statusSummaryRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * @TODO not totally sure how to use the serializer here yet.
     * @param {StorageStatus} storageStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusStorageCreate(storageStatus: StorageStatus, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusStorageCreate(storageStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return counts of all models.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusSummaryRetrieve(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusSummaryRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {StorageSource} storageSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageCreate: async (storageSource: StorageSource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageSource' is not null or undefined
            assertParamExists('storageCreate', 'storageSource', storageSource)
            const localVarPath = `/api/v2/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storageDestroy', 'id', id)
            const localVarPath = `/api/v2/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageList: async (deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deployments) {
                localVarQueryParameter['deployments'] = deployments;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {PatchedStorageSource} [patchedStorageSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storagePartialUpdate: async (id: number, patchedStorageSource?: PatchedStorageSource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storagePartialUpdate', 'id', id)
            const localVarPath = `/api/v2/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStorageSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storageRetrieve', 'id', id)
            const localVarPath = `/api/v2/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {StorageSource} storageSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUpdate: async (id: number, storageSource: StorageSource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storageUpdate', 'id', id)
            // verify required parameter 'storageSource' is not null or undefined
            assertParamExists('storageUpdate', 'storageSource', storageSource)
            const localVarPath = `/api/v2/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {StorageSource} storageSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageCreate(storageSource: StorageSource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageCreate(storageSource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedStorageSourceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageList(deployments, limit, offset, ordering, project, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {PatchedStorageSource} [patchedStorageSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storagePartialUpdate(id: number, patchedStorageSource?: PatchedStorageSource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storagePartialUpdate(id, patchedStorageSource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storagePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {StorageSource} storageSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUpdate(id: number, storageSource: StorageSource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUpdate(id, storageSource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {StorageSource} storageSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageCreate(storageSource: StorageSource, options?: any): AxiosPromise<StorageSource> {
            return localVarFp.storageCreate(storageSource, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.storageDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {Array<number>} [deployments] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [project] 
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: any): AxiosPromise<PaginatedStorageSourceList> {
            return localVarFp.storageList(deployments, limit, offset, ordering, project, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {PatchedStorageSource} [patchedStorageSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storagePartialUpdate(id: number, patchedStorageSource?: PatchedStorageSource, options?: any): AxiosPromise<StorageSource> {
            return localVarFp.storagePartialUpdate(id, patchedStorageSource, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageRetrieve(id: number, options?: any): AxiosPromise<StorageSource> {
            return localVarFp.storageRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows storage sources to be viewed or edited.
         * @param {number} id A unique integer value identifying this s3 storage source.
         * @param {StorageSource} storageSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUpdate(id: number, storageSource: StorageSource, options?: any): AxiosPromise<StorageSource> {
            return localVarFp.storageUpdate(id, storageSource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
    /**
     * API endpoint that allows storage sources to be viewed or edited.
     * @param {StorageSource} storageSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageCreate(storageSource: StorageSource, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageCreate(storageSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows storage sources to be viewed or edited.
     * @param {number} id A unique integer value identifying this s3 storage source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageDestroy(id: number, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows storage sources to be viewed or edited.
     * @param {Array<number>} [deployments] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [project] 
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageList(deployments?: Array<number>, limit?: number, offset?: number, ordering?: string, project?: number, search?: string, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageList(deployments, limit, offset, ordering, project, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows storage sources to be viewed or edited.
     * @param {number} id A unique integer value identifying this s3 storage source.
     * @param {PatchedStorageSource} [patchedStorageSource] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storagePartialUpdate(id: number, patchedStorageSource?: PatchedStorageSource, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storagePartialUpdate(id, patchedStorageSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows storage sources to be viewed or edited.
     * @param {number} id A unique integer value identifying this s3 storage source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows storage sources to be viewed or edited.
     * @param {number} id A unique integer value identifying this s3 storage source.
     * @param {StorageSource} storageSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageUpdate(id: number, storageSource: StorageSource, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageUpdate(id, storageSource, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaxaApi - axios parameter creator
 * @export
 */
export const TaxaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {Taxon} taxon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaCreate: async (taxon: Taxon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxon' is not null or undefined
            assertParamExists('taxaCreate', 'taxon', taxon)
            const localVarPath = `/api/v2/taxa/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxaDestroy', 'id', id)
            const localVarPath = `/api/v2/taxa/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [occurrencesDeployment] 
         * @param {number} [occurrencesEvent] 
         * @param {number} [occurrencesProject] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [parent] 
         * @param {Array<number>} [projects] 
         * @param {TaxaListRankEnum} [rank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaList: async (limit?: number, name?: string, occurrencesDeployment?: number, occurrencesEvent?: number, occurrencesProject?: number, offset?: number, ordering?: string, parent?: number, projects?: Array<number>, rank?: TaxaListRankEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/taxa/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (occurrencesDeployment !== undefined) {
                localVarQueryParameter['occurrences__deployment'] = occurrencesDeployment;
            }

            if (occurrencesEvent !== undefined) {
                localVarQueryParameter['occurrences__event'] = occurrencesEvent;
            }

            if (occurrencesProject !== undefined) {
                localVarQueryParameter['occurrences__project'] = occurrencesProject;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (projects) {
                localVarQueryParameter['projects'] = projects;
            }

            if (rank !== undefined) {
                localVarQueryParameter['rank'] = rank;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {PatchedTaxon} [patchedTaxon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaPartialUpdate: async (id: number, patchedTaxon?: PatchedTaxon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxaPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/taxa/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTaxon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxaRetrieve', 'id', id)
            const localVarPath = `/api/v2/taxa/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of taxa that match the query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaSuggestRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/taxa/suggest/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {Taxon} taxon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaUpdate: async (id: number, taxon: Taxon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taxaUpdate', 'id', id)
            // verify required parameter 'taxon' is not null or undefined
            assertParamExists('taxaUpdate', 'taxon', taxon)
            const localVarPath = `/api/v2/taxa/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxon, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxaApi - functional programming interface
 * @export
 */
export const TaxaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaxaApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {Taxon} taxon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxaCreate(taxon: Taxon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxaCreate(taxon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaxaApi.taxaCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxaDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxaDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaxaApi.taxaDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [occurrencesDeployment] 
         * @param {number} [occurrencesEvent] 
         * @param {number} [occurrencesProject] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [parent] 
         * @param {Array<number>} [projects] 
         * @param {TaxaListRankEnum} [rank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxaList(limit?: number, name?: string, occurrencesDeployment?: number, occurrencesEvent?: number, occurrencesProject?: number, offset?: number, ordering?: string, parent?: number, projects?: Array<number>, rank?: TaxaListRankEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTaxonListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxaList(limit, name, occurrencesDeployment, occurrencesEvent, occurrencesProject, offset, ordering, parent, projects, rank, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaxaApi.taxaList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {PatchedTaxon} [patchedTaxon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxaPartialUpdate(id: number, patchedTaxon?: PatchedTaxon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxaPartialUpdate(id, patchedTaxon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaxaApi.taxaPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxaRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxaRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaxaApi.taxaRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of taxa that match the query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxaSuggestRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxaSuggestRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaxaApi.taxaSuggestRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {Taxon} taxon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taxaUpdate(id: number, taxon: Taxon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Taxon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taxaUpdate(id, taxon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaxaApi.taxaUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TaxaApi - factory interface
 * @export
 */
export const TaxaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaxaApiFp(configuration)
    return {
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {Taxon} taxon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaCreate(taxon: Taxon, options?: any): AxiosPromise<Taxon> {
            return localVarFp.taxaCreate(taxon, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.taxaDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [occurrencesDeployment] 
         * @param {number} [occurrencesEvent] 
         * @param {number} [occurrencesProject] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [parent] 
         * @param {Array<number>} [projects] 
         * @param {TaxaListRankEnum} [rank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaList(limit?: number, name?: string, occurrencesDeployment?: number, occurrencesEvent?: number, occurrencesProject?: number, offset?: number, ordering?: string, parent?: number, projects?: Array<number>, rank?: TaxaListRankEnum, search?: string, options?: any): AxiosPromise<PaginatedTaxonListList> {
            return localVarFp.taxaList(limit, name, occurrencesDeployment, occurrencesEvent, occurrencesProject, offset, ordering, parent, projects, rank, search, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {PatchedTaxon} [patchedTaxon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaPartialUpdate(id: number, patchedTaxon?: PatchedTaxon, options?: any): AxiosPromise<Taxon> {
            return localVarFp.taxaPartialUpdate(id, patchedTaxon, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaRetrieve(id: number, options?: any): AxiosPromise<Taxon> {
            return localVarFp.taxaRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of taxa that match the query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaSuggestRetrieve(options?: any): AxiosPromise<Taxon> {
            return localVarFp.taxaSuggestRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows taxa to be viewed or edited.
         * @param {number} id A unique integer value identifying this taxon.
         * @param {Taxon} taxon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxaUpdate(id: number, taxon: Taxon, options?: any): AxiosPromise<Taxon> {
            return localVarFp.taxaUpdate(id, taxon, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxaApi - object-oriented interface
 * @export
 * @class TaxaApi
 * @extends {BaseAPI}
 */
export class TaxaApi extends BaseAPI {
    /**
     * API endpoint that allows taxa to be viewed or edited.
     * @param {Taxon} taxon 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxaApi
     */
    public taxaCreate(taxon: Taxon, options?: RawAxiosRequestConfig) {
        return TaxaApiFp(this.configuration).taxaCreate(taxon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows taxa to be viewed or edited.
     * @param {number} id A unique integer value identifying this taxon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxaApi
     */
    public taxaDestroy(id: number, options?: RawAxiosRequestConfig) {
        return TaxaApiFp(this.configuration).taxaDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows taxa to be viewed or edited.
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [occurrencesDeployment] 
     * @param {number} [occurrencesEvent] 
     * @param {number} [occurrencesProject] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [parent] 
     * @param {Array<number>} [projects] 
     * @param {TaxaListRankEnum} [rank] * &#x60;ORDER&#x60; - Order * &#x60;SUPERFAMILY&#x60; - Superfamily * &#x60;FAMILY&#x60; - Family * &#x60;SUBFAMILY&#x60; - Subfamily * &#x60;TRIBE&#x60; - Tribe * &#x60;SUBTRIBE&#x60; - Subtribe * &#x60;GENUS&#x60; - Genus * &#x60;SPECIES&#x60; - Species * &#x60;UNKNOWN&#x60; - Unknown
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxaApi
     */
    public taxaList(limit?: number, name?: string, occurrencesDeployment?: number, occurrencesEvent?: number, occurrencesProject?: number, offset?: number, ordering?: string, parent?: number, projects?: Array<number>, rank?: TaxaListRankEnum, search?: string, options?: RawAxiosRequestConfig) {
        return TaxaApiFp(this.configuration).taxaList(limit, name, occurrencesDeployment, occurrencesEvent, occurrencesProject, offset, ordering, parent, projects, rank, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows taxa to be viewed or edited.
     * @param {number} id A unique integer value identifying this taxon.
     * @param {PatchedTaxon} [patchedTaxon] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxaApi
     */
    public taxaPartialUpdate(id: number, patchedTaxon?: PatchedTaxon, options?: RawAxiosRequestConfig) {
        return TaxaApiFp(this.configuration).taxaPartialUpdate(id, patchedTaxon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows taxa to be viewed or edited.
     * @param {number} id A unique integer value identifying this taxon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxaApi
     */
    public taxaRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return TaxaApiFp(this.configuration).taxaRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of taxa that match the query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxaApi
     */
    public taxaSuggestRetrieve(options?: RawAxiosRequestConfig) {
        return TaxaApiFp(this.configuration).taxaSuggestRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint that allows taxa to be viewed or edited.
     * @param {number} id A unique integer value identifying this taxon.
     * @param {Taxon} taxon 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxaApi
     */
    public taxaUpdate(id: number, taxon: Taxon, options?: RawAxiosRequestConfig) {
        return TaxaApiFp(this.configuration).taxaUpdate(id, taxon, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TaxaListRankEnum = {
    Family: 'FAMILY',
    Genus: 'GENUS',
    Order: 'ORDER',
    Species: 'SPECIES',
    Subfamily: 'SUBFAMILY',
    Subtribe: 'SUBTRIBE',
    Superfamily: 'SUPERFAMILY',
    Tribe: 'TRIBE',
    Unknown: 'UNKNOWN'
} as const;
export type TaxaListRankEnum = typeof TaxaListRankEnum[keyof typeof TaxaListRankEnum];


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Activation} activation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActivationCreate: async (activation: Activation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activation' is not null or undefined
            assertParamExists('usersActivationCreate', 'activation', activation)
            const localVarPath = `/api/v2/users/activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('usersCreate', 'userCreate', userCreate)
            const localVarPath = `/api/v2/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDestroy', 'id', id)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeDestroy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedCurrentUser} [patchedCurrentUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePartialUpdate: async (patchedCurrentUser?: PatchedCurrentUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCurrentUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CurrentUser} [currentUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUpdate: async (currentUser?: CurrentUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currentUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUser?: PatchedUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResendActivationCreate: async (sendEmailReset: SendEmailReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEmailReset' is not null or undefined
            assertParamExists('usersResendActivationCreate', 'sendEmailReset', sendEmailReset)
            const localVarPath = `/api/v2/users/resend_activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEmailReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UsernameResetConfirm} usernameResetConfirm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetEmailConfirmCreate: async (usernameResetConfirm: UsernameResetConfirm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usernameResetConfirm' is not null or undefined
            assertParamExists('usersResetEmailConfirmCreate', 'usernameResetConfirm', usernameResetConfirm)
            const localVarPath = `/api/v2/users/reset_email_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usernameResetConfirm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetEmailCreate: async (sendEmailReset: SendEmailReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEmailReset' is not null or undefined
            assertParamExists('usersResetEmailCreate', 'sendEmailReset', sendEmailReset)
            const localVarPath = `/api/v2/users/reset_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEmailReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordResetConfirm} passwordResetConfirm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetPasswordConfirmCreate: async (passwordResetConfirm: PasswordResetConfirm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetConfirm' is not null or undefined
            assertParamExists('usersResetPasswordConfirmCreate', 'passwordResetConfirm', passwordResetConfirm)
            const localVarPath = `/api/v2/users/reset_password_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetConfirm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetPasswordCreate: async (sendEmailReset: SendEmailReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEmailReset' is not null or undefined
            assertParamExists('usersResetPasswordCreate', 'sendEmailReset', sendEmailReset)
            const localVarPath = `/api/v2/users/reset_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEmailReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUsername} setUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSetEmailCreate: async (setUsername: SetUsername, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUsername' is not null or undefined
            assertParamExists('usersSetEmailCreate', 'setUsername', setUsername)
            const localVarPath = `/api/v2/users/set_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUsername, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetPassword} setPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSetPasswordCreate: async (setPassword: SetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setPassword' is not null or undefined
            assertParamExists('usersSetPasswordCreate', 'setPassword', setPassword)
            const localVarPath = `/api/v2/users/set_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Activation} activation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersActivationCreate(activation: Activation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersActivationCreate(activation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersActivationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeDestroy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeDestroy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersMeDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PatchedCurrentUser} [patchedCurrentUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMePartialUpdate(patchedCurrentUser?: PatchedCurrentUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMePartialUpdate(patchedCurrentUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersMePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersMeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CurrentUser} [currentUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeUpdate(currentUser?: CurrentUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeUpdate(currentUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersMeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersResendActivationCreate(sendEmailReset: SendEmailReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersResendActivationCreate(sendEmailReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersResendActivationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UsernameResetConfirm} usernameResetConfirm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersResetEmailConfirmCreate(usernameResetConfirm: UsernameResetConfirm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsernameResetConfirm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersResetEmailConfirmCreate(usernameResetConfirm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersResetEmailConfirmCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersResetEmailCreate(sendEmailReset: SendEmailReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersResetEmailCreate(sendEmailReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersResetEmailCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PasswordResetConfirm} passwordResetConfirm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersResetPasswordConfirmCreate(passwordResetConfirm: PasswordResetConfirm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetConfirm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersResetPasswordConfirmCreate(passwordResetConfirm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersResetPasswordConfirmCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersResetPasswordCreate(sendEmailReset: SendEmailReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersResetPasswordCreate(sendEmailReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersResetPasswordCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetUsername} setUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSetEmailCreate(setUsername: SetUsername, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetUsername>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSetEmailCreate(setUsername, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersSetEmailCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetPassword} setPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersSetPasswordCreate(setPassword: SetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetPassword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersSetPasswordCreate(setPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersSetPasswordCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {Activation} activation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActivationCreate(activation: Activation, options?: any): AxiosPromise<Activation> {
            return localVarFp.usersActivationCreate(activation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(userCreate: UserCreate, options?: any): AxiosPromise<UserCreate> {
            return localVarFp.usersCreate(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedUserList> {
            return localVarFp.usersList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeDestroy(options?: any): AxiosPromise<void> {
            return localVarFp.usersMeDestroy(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedCurrentUser} [patchedCurrentUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePartialUpdate(patchedCurrentUser?: PatchedCurrentUser, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.usersMePartialUpdate(patchedCurrentUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.usersMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CurrentUser} [currentUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUpdate(currentUser?: CurrentUser, options?: any): AxiosPromise<CurrentUser> {
            return localVarFp.usersMeUpdate(currentUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResendActivationCreate(sendEmailReset: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return localVarFp.usersResendActivationCreate(sendEmailReset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsernameResetConfirm} usernameResetConfirm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetEmailConfirmCreate(usernameResetConfirm: UsernameResetConfirm, options?: any): AxiosPromise<UsernameResetConfirm> {
            return localVarFp.usersResetEmailConfirmCreate(usernameResetConfirm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetEmailCreate(sendEmailReset: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return localVarFp.usersResetEmailCreate(sendEmailReset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PasswordResetConfirm} passwordResetConfirm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetPasswordConfirmCreate(passwordResetConfirm: PasswordResetConfirm, options?: any): AxiosPromise<PasswordResetConfirm> {
            return localVarFp.usersResetPasswordConfirmCreate(passwordResetConfirm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} sendEmailReset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetPasswordCreate(sendEmailReset: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return localVarFp.usersResetPasswordCreate(sendEmailReset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUsername} setUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSetEmailCreate(setUsername: SetUsername, options?: any): AxiosPromise<SetUsername> {
            return localVarFp.usersSetEmailCreate(setUsername, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetPassword} setPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSetPasswordCreate(setPassword: SetPassword, options?: any): AxiosPromise<SetPassword> {
            return localVarFp.usersSetPasswordCreate(setPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {Activation} activation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersActivationCreate(activation: Activation, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersActivationCreate(activation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDestroy(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeDestroy(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeDestroy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PatchedCurrentUser} [patchedCurrentUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMePartialUpdate(patchedCurrentUser?: PatchedCurrentUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMePartialUpdate(patchedCurrentUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeRetrieve(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CurrentUser} [currentUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeUpdate(currentUser?: CurrentUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeUpdate(currentUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUser} [patchedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} sendEmailReset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersResendActivationCreate(sendEmailReset: SendEmailReset, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersResendActivationCreate(sendEmailReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsernameResetConfirm} usernameResetConfirm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersResetEmailConfirmCreate(usernameResetConfirm: UsernameResetConfirm, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersResetEmailConfirmCreate(usernameResetConfirm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} sendEmailReset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersResetEmailCreate(sendEmailReset: SendEmailReset, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersResetEmailCreate(sendEmailReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PasswordResetConfirm} passwordResetConfirm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersResetPasswordConfirmCreate(passwordResetConfirm: PasswordResetConfirm, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersResetPasswordConfirmCreate(passwordResetConfirm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} sendEmailReset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersResetPasswordCreate(sendEmailReset: SendEmailReset, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersResetPasswordCreate(sendEmailReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUsername} setUsername 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersSetEmailCreate(setUsername: SetUsername, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersSetEmailCreate(setUsername, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetPassword} setPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersSetPasswordCreate(setPassword: SetPassword, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersSetPasswordCreate(setPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, user?: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}



